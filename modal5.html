<!-- ========= modal5.html (Проект 5) =========  -->
<div id="modal5-container" class="modal5-shell">
  <link href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined" rel="stylesheet">
  <style>
    #modal5-container {
      position: relative;
      display: flex;
      flex-direction: column;
      justify-content: flex-start;
      align-items: center;
      width: 100%;
      height: 100vh;
      padding: 20px 0;
      margin: 0;
      box-sizing: border-box;
      color: var(--content-color, #212121);
      font-family: 'Comfortaa', sans-serif;
    }

    #modal5-container .glass-panel {
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid var(--content-color, #212121);
      border-radius: 12px;
      box-shadow:
        0 0 0.75px hsl(205 20% 10% / 0.24),
        0.7px 0.8px 1.2px -0.4px hsl(205 20% 10% / 0.16),
        1.3px 1.5px 2.2px -0.8px hsl(205 20% 10% / 0.16),
        2.3px 2.6px 3.9px -1.2px hsl(205 20% 10% / 0.16),
        3.9px 4.4px 6.6px -1.7px hsl(205 20% 10% / 0.16),
        6.5px 7.2px 10.9px -2.1px hsl(205 20% 10% / 0.18);
      backdrop-filter: blur(3px);
      -webkit-backdrop-filter: blur(3px);
    }

    #modal5-container .modal-top {
      width: 1930px;
      max-width: 90vw;
      min-height: 255px;
      display: flex;
      flex-direction: column;
      justify-content: flex-end;
      gap: 18px;
      margin-top: -20px;
      padding: 20px;
      padding-top: 80px;
      box-sizing: border-box;
      color: var(--black-color, var(--content-color, #212121));
      position: relative;
      overflow: hidden;
      isolation: isolate;
    }

    #modal5-container .modal5-signature {
      position: absolute;
      top: 10px;
      left: 10px;
      display: flex;
      justify-content: center;
      align-items: center;
      padding: 6px 10px;
      border-radius: 10px;
      background: rgba(255, 255, 255, 0.08);
      border: 1px solid rgba(255, 255, 255, 0.2);
      box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.05);
    }

    #modal5-container .modal5-signature h2 {
      margin: 0;
      font-size: 1.4em;
      color: #212121;
      text-transform: uppercase;
      display: flex;
      gap: 2px;
    }

    #modal5-container .modal5-signature h2 span {
      transition: 1.5s;
      display: inline-block;
    }

    #modal5-container .modal5-signature h2:hover span {
      filter: blur(20px);
      opacity: 0;
      transform: scale(2);
    }

    #modal5-container .modal5-signature h2 span:nth-child(1) { transition-delay: 0s; }
    #modal5-container .modal5-signature h2 span:nth-child(2) { transition-delay: 0.1s; }
    #modal5-container .modal5-signature h2 span:nth-child(3) { transition-delay: 0.2s; }
    #modal5-container .modal5-signature h2 span:nth-child(4) { transition-delay: 0.3s; }
    #modal5-container .modal5-signature h2 span:nth-child(5) { transition-delay: 0.4s; }
    #modal5-container .modal5-signature h2 span:nth-child(6) { transition-delay: 0.5s; }
    #modal5-container .modal5-signature h2 span:nth-child(7) { transition-delay: 0.6s; }
    #modal5-container .modal5-signature h2 span:nth-child(8) { transition-delay: 0.7s; }
    #modal5-container .modal5-signature h2 span:nth-child(9) { transition-delay: 0.8s; }
    #modal5-container .modal5-signature h2 span:nth-child(10) { transition-delay: 0.9s; }
    #modal5-container .modal5-signature h2 span:nth-child(11) { transition-delay: 1s; }
    #modal5-container .modal5-signature h2 span:nth-child(12) { transition-delay: 1.1s; }
    #modal5-container .modal5-signature h2 span:nth-child(13) { transition-delay: 1.2s; }
    #modal5-container .modal5-signature h2 span:nth-child(14) { transition-delay: 1.3s; }
    #modal5-container .modal5-signature h2 span:nth-child(15) { transition-delay: 1.4s; }
    #modal5-container .modal5-signature h2 span:nth-child(16) { transition-delay: 1.5s; }
    
    #modal5-container .modal5-signature h2 span:nth-child(17) { transition-delay: 1.6s; }
    #modal5-container .modal5-signature h2 span:nth-child(18) { transition-delay: 1.7s; }
    #modal5-container .modal5-signature h2 span:nth-child(19) { transition-delay: 1.8s; }
    #modal5-container .modal5-signature h2 span:nth-child(20) { transition-delay: 1.9s; }
    #modal5-container .modal5-signature h2 span:nth-child(21) { transition-delay: 2s; }
    #modal5-container .modal5-signature h2 span:nth-child(22) { transition-delay: 2.1s; }
    #modal5-container .modal5-signature h2 span:nth-child(23) { transition-delay: 2.2s; }
    #modal5-container .modal5-signature h2 span:nth-child(24) { transition-delay: 2.3s; }
    #modal5-container .modal5-signature h2 span:nth-child(25) { transition-delay: 2.4s; }
    #modal5-container .modal5-signature h2 span:nth-child(26) { transition-delay: 2.5s; }
    #modal5-container .modal5-signature h2 span:nth-child(27) { transition-delay: 2.6s; }
    #modal5-container .modal5-signature h2 span:nth-child(28) { transition-delay: 2.7s; }

    #modal5-container .modal5-signature h2 span.warehouse-letter {
      font-size: 0.85em;
      margin-top: 2px;
      color: #9EA793;
    }

    #modal5-container .modalRow {
      display: flex;
      flex-wrap: wrap;
      flex-direction: row;
      gap: 14px;
    }
   
    #modal5-container .recipe-card__header {
      height: 30px;
      align-items: center;
      flex-wrap: nowrap;
    }

    #modal5-container .recipe-card__header .button-form,
    #modal5-container .recipe-card__header .inputSUM {
      height: 100%;
      line-height: 30px;
      padding-top: 0;
      padding-bottom: 0;
      box-sizing: border-box;
    }

    #modal5-container .recipe-card__header .button-form {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding-left: 12px;
      padding-right: 12px;
    }

    #modal5-container .recipe-card__header .inputSUM {
      padding-left: 10px;
      padding-right: 10px;
    }

    #modal5-container .modalColumn {
      display: flex;
      flex-wrap: wrap;
      flex-direction: column;
      gap: 14px;
    }

    #modal5-container .stats-row {
      justify-content: space-between;
      gap: 16px;
    }

    #modal5-container .stat-card {
      flex: 1;
      min-width: 240px;
      padding: 18px 20px;
      border-radius: 10px;
      background: rgba(255, 255, 255, 0.08);
      border: 1px solid rgba(255, 255, 255, 0.25);
      box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.08);
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    #modal5-container .stat-title {
      text-transform: uppercase;
      font-size: 14px;
      font-weight: 700;
      letter-spacing: 0.08em;
      color: var(--content-color, #212121);
    }

    #modal5-container .stat-value {
      font-size: 32px;
      font-weight: 700;
      line-height: 1.2;
      color: var(--content-color, #212121);
    }

    #modal5-container .stat-subtitle {
      font-size: 12px;
      opacity: 0.75;
    }

    #modal5-container .form-row {
      align-items: flex-end;
      gap: 18px;
      margin-top: 0;
    }

    #modal5-container .form-row .button-form {
      align-self: flex-end;
    }

    #modal5-container .form-fields {
      flex: 1;
      /* padding: 18px 20px; */
      padding: 0px 20px;
      border-radius: 10px;
      background: rgba(255, 255, 255, 0.04);
      border: 1px solid rgba(255, 255, 255, 0.18);
      box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.05);
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    #modal5-container .form-fields .modalRow {
      gap: 12px;
    }

    #modal5-container .form-fields .filters-hint {
      font-size: 11px;
      opacity: 0.7;
      text-transform: uppercase;
      letter-spacing: 0.08em;
    }

    #modal5-container .radio-inputs {
      position: relative;
      display: flex;
      flex-wrap: wrap;
      border-radius: 0.5rem;
      background: var(--content-color, #212121);
      border: 1px solid var(--content-color, #212121);
      color: var(--fon, #f5f5f5);
      padding: 2px 2px;
      font-size: 12px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.06em;
      box-sizing: border-box;
      box-shadow: 0 0 0px 1px rgba(0, 0, 0, 0.06);
      width: 300px;
      height: 30px;
      align-self: center;
      margin-top: 10px;
      gap: 0.25rem;
    }

    #modal5-container .radio-inputs .radio {
      flex: 1 1 auto;
      text-align: center;
    }

    #modal5-container .radio-inputs .radio input {
      display: none;
    }

    #modal5-container .radio-inputs .radio .name {
      display: flex;
      cursor: pointer;
      align-items: center;
      justify-content: center;
      border-radius: 0.5rem;
      border: none;
      padding: .5rem 0;
      color: rgba(51, 65, 85, 1);
      transition: all .15s ease-in-out;
      text-transform: uppercase;
      letter-spacing: 0.06em;
      font-weight: 500;
    }

    #modal5-container .radio-inputs .radio input:checked + .name {
      color: var(--content-color, #212121);
      background: rgba(255, 255, 255, 0.12);
    }

    #modal5-container .button-form {
      position: relative;
      min-width: 220px;
      height: 30px;
      background: var(--content-color, #212121);
      border: 1px solid var(--content-color, #212121);
      color: var(--fon, #f5f5f5);
      cursor: pointer;
      transition: all 0.3s ease;
      padding: 8px 12px;
      border-radius: 8px;
      font-size: 12px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.06em;
    }

    #modal5-container .button-form:hover {
      color: var(--content-color, #212121);
      background: rgba(255, 255, 255, 0.12);
    }

    #modal5-container .button-form.primary {
      min-width: 200px;
    }

    #modal5-container .modal5-scroll-wrapper {
      width: 1950px;
      max-width: 90vw;
      flex: 1;
      padding-bottom: 20px;
      overflow: visible;
    }

    #modal5-container .modal5-window {
      color: var(--black-color, var(--content-color, #212121));
      width: 1930px;
      max-width: 90vw;
      padding-top: 20px;
      padding-bottom: 20px;
      padding-left: 20px;
      padding-right: 10px;
      box-sizing: border-box;
      margin: 0;
      display: flex;
      flex-direction: column;
      position: fixed;
      top: 275px;
      bottom: 0;
      left: 50%;
      transform: translateX(-50%);
      max-height: calc(100vh - 220px);
      overflow-x: visible;
    }

    #modal5-container .modal5-content {
      width: 1930px;
      height: 100%;
      box-sizing: border-box;
      overflow-y: auto;
      padding-right: 10px;
      margin-right: -10px;
      transition: opacity 0.3s ease;
      opacity: 1;
    }

    #modal5-container .modal5-content::-webkit-scrollbar { width: 6px; }
    #modal5-container .modal5-content::-webkit-scrollbar-track { background: transparent; }
    #modal5-container .modal5-content::-webkit-scrollbar-thumb { background-color: var(--content-color, #212121); border-radius: 10px; }

    #modal5-container .modalVNUT-content .modalBLOCK {
      display: flex;
      flex-direction: column;
      gap: 12px;
      border-radius: 10px;
      background: rgba(255, 255, 255, 0.04);
      transition: transform 0.25s ease, box-shadow 0.25s ease;
      margin-bottom: 12px;
      padding: 18px 20px;
      border: 1px solid rgba(255, 255, 255, 0.12);
    }

    #modal5-container .modalVNUT-content .modalBLOCK:hover {
      transform: translateY(-2px);
    }

    #modal5-container .recipe-card {
      /* border: 1px solid #212121; */
      border-radius: 10px;
      padding: 0px;
      /* padding: 18px 20px;
      margin-top: 16px;
      margin-left: 12px; */
      background: rgba(255, 255, 255, 0.05);
      display: grid;
      grid-template-columns: 1fr 300px;
      grid-template-rows: auto 1fr auto;
      column-gap: 20px;
      row-gap: 16px;
      box-sizing: border-box;
    }

    #modal5-container .recipe-card__header {
      display: flex;
      flex-wrap: nowrap;
      align-items: center;
      gap: 12px;
      grid-column: 1;
      height: 30px;
    }

    #modal5-container .recipe-card__body {
      display: flex;
      flex-direction: column;
      gap: 16px;
      grid-column: 1;
      grid-row: 2;
    }

    #modal5-container .recipe-card__visual {
      grid-column: 2;
      grid-row: 1 / span 3;
      align-self: start;
      justify-self: end;
      margin: 0;
      width: 100%;
    }

    #modal5-container .recipe-card__manufacture-controls {
      display: flex;
      align-items: center;
      gap: 12px;
      max-height: 0;
      opacity: 0;
      pointer-events: none;
      transition: max-height 0.5s ease, opacity 0.5s ease;
    }

    #modal5-container .recipe-card__manufacture-controls.is-visible {
      max-height: 80px;
      opacity: 1;
      pointer-events: auto;
    }

    #modal5-container .recipe-card__manufacture-controls[hidden],
    #modal5-container .recipe-card__common-notes[hidden] {
      display: none !important;
    }

    #modal5-container .recipe-card__manufacture-result[hidden] {
      display: none !important;
    }

    #modal5-container .recipe-card__manufacture-chart {
      display: flex;
      flex-direction: column;
      justify-content: center;
      gap: 4px;
      min-width: 350px;
      padding: 0;
      height: 30px;
    }

    #modal5-container .recipe-card__manufacture-chart[hidden] {
      display: none !important;
    }

    #modal5-container .manufacture-chart__grid {
      display: grid;
      grid-template-columns: repeat(20, minmax(0, 1fr));
      gap: 3px;
      align-items: center;
    }

    #modal5-container .manufacture-chart__cell {
      position: relative;
      width: 100%;
      aspect-ratio: 1 / 1;
      border-radius: 4px;
      /* цвет покоя квадратов */
      background: #C5C6CB;
      overflow: hidden;
    }

    #modal5-container .manufacture-chart__cell-fill,
    #modal5-container .manufacture-chart__cell-overflow {
      position: absolute;
      inset: 0;
      border-radius: inherit;
      transform: scaleX(0);
      transition: transform 0.35s ease;
    }

    #modal5-container .manufacture-chart__cell-fill {
      /* цвет расхода квадратов */
      background: #212121;
      transform-origin: left center;
    }

    #modal5-container .manufacture-chart__cell-overflow {
      /* цвет ПЕРЕрасхода квадратов */
      background: #F56E0F;
      transform-origin: right center;
    }

    #modal5-container .manufacture-chart__cell[aria-hidden="true"] .manufacture-chart__cell-fill,
    #modal5-container .manufacture-chart__cell[aria-hidden="true"] .manufacture-chart__cell-overflow {
      transition: none;
    }

    #modal5-container .manufacture-chart__cell {
      --fill: 0;
      --overflow: 0;
    }

    #modal5-container .manufacture-chart__cell-fill {
      transform: scaleX(var(--fill, 0));
    }

    #modal5-container .manufacture-chart__cell-overflow {
      transform: scaleX(var(--overflow, 0));
      opacity: var(--overflow, 0);
    }

    #modal5-container .recipe-card__manufacture-balance {
      margin-left: 6px;
    }

    #modal5-container .recipe-card__manufacture-balance[hidden] {
      display: none !important;
    }

    #modal5-container .recipe-card__manufacture-balance.is-overflow {
      color: #F56E0F;
      font-weight: 900;
    }

    #modal5-container .recipe-card__common-notes {
      position: absolute;
      top: 0;
      right: 0;
      display: flex;
      flex-direction: column;
      gap: 8px;
      width: 540px;
      max-width: 100%;
      padding-left: 30px;
      box-sizing: border-box;
      transition: opacity 0.3s ease;
      z-index: 2;
    }

    #modal5-container .recipe-card__common-notes[hidden] {
      display: none !important;
    }

    #modal5-container .recipe-card__common-notes.is-hidden {
      opacity: 0;
    }

    #modal5-container .recipe-card__common-notes-textarea {
      width: 100%;
      height: 270px;
      resize: none;
      }

    @media screen and (max-width: 1500px) {
      #modal5-container .recipe-card__workspace {
        display: flex;
        flex-direction: column;
      }

      #modal5-container .recipe-card__common-notes {
        position: static;
        max-width: 100%;
        width: 100%;
        padding-left: 0;
      }
    }

    #modal5-container .recipe-card__delete {
      margin-left: auto;
    }

    #modal5-container .recipe-visual-card {
      width: 100%;
      /* padding: 10px; */
      background: #212121;
      border-radius: 10px;
      overflow: hidden;
      box-sizing: border-box;
    }

    #modal5-container .recipe-visual-card__inner {
      position: relative;
      width: 100%;
      height: 360px;
      background: #ffffff;
      border-bottom-right-radius: 0px;
    }

    #modal5-container .recipe-visual-card__box {
      position: relative;
      width: 100%;
      height: 100%;
      background: #ffffff;
      border-radius: 10px;
      overflow: hidden;
    }

    #modal5-container .recipe-visual-card__image {
      position: absolute;
      top: 0px;
      right: 0px;
      bottom: 0px;
      left: 0px;
    }

    #modal5-container .recipe-visual-card__image img {
      width: 100%;
      height: 100%;
      object-fit: cover;
      object-position: center;
      border-radius: 10px;
      transition: opacity 0.2s ease;
    }

    #modal5-container .recipe-visual-card__footer {
      position: absolute;
      bottom: -6px;
      right: 0px;
      width: 100%;
      height: 48px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      background: #ffffff;
      pointer-events: none;
    }

    #modal5-container .recipe-visual-card__footer h3 {
      margin-left: 8px;
      text-transform: uppercase;
      font-size: 14px;
      color: #c8c8c8;
      font-weight: 400;
    }

    #modal5-container .recipe-visual-card__button {
      position: relative;
      margin-right: 20px;
      height: 28px;
      padding: 4px 14px;
      border-radius: 8px;
      background-color: #111111;
      color: #ffffff;
      font-size: 12px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.8px;
      border: none;
      cursor: pointer;
      transition: background-color 0.2s ease, transform 0.2s ease;
      pointer-events: auto;
    }

    #modal5-container .recipe-visual-card__button:hover,
    #modal5-container .recipe-visual-card__button:focus {
      background-color: #2a2a2a;
      outline: none;
      transform: translateY(-1px);
    }

    #modal5-container .recipe-visual-card__input {
      position: absolute;
      opacity: 0;
      pointer-events: none;
      width: 0px;
      height: 0px;
    }

    #modal5-container .recipe-visual-card__footer::before {
      position: absolute;
      content: "";
      bottom: 6px;
      left: -20px;
      background: transparent;
      width: 20px;
      height: 20px;
      border-bottom-right-radius: 10px;
      box-shadow: 5px 5px 0px 5px #ffffff;
      pointer-events: none;
    }

    #modal5-container .recipe-visual-card__footer::after {
      position: absolute;
      content: "";
      top: -20px;
      right: 6px;
      background: transparent;
      width: 20px;
      height: 20px;
      border-bottom-right-radius: 10px;
      box-shadow: 5px 5px 0px 5px #ffffff;
      pointer-events: none;
    }

    @media screen and (min-width: 848px) {
      #modal5-container .recipe-visual-card {
        border-radius: 10px;
      }

      #modal5-container .recipe-visual-card__box {
        border-radius: 10px;
      }

      #modal5-container .recipe-visual-card__image img {
        border-radius: 10px;
      }

      #modal5-container .recipe-visual-card__footer {
        width: 130px;
        right: -6px;
        border-top-left-radius: 10px;
      }

      #modal5-container .recipe-visual-card__footer h3 {
        margin-left: 16px;
      }

      #modal5-container .recipe-visual-card__footer::before {
        bottom: 6px;
        left: -20px;
        width: 20px;
        height: 20px;
        border-bottom-right-radius: 10px;
      }

      #modal5-container .recipe-visual-card__footer::after {
        top: -20px;
        right: 6px;
        width: 20px;
        height: 20px;
        border-bottom-right-radius: 10px;
      }
    }

    #modal5-container .recipe-card__controls {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      align-items: center;
      position: relative;
    }

    #modal5-container .recipe-card__controls .recipe-card__header {
      position: relative;
    }

    @media screen and (max-width: 1280px) {
      #modal5-container .recipe-card__controls {
        padding-bottom: 0;
      }
    }

    #modal5-container .recipe-card__picker {
      display: none;
      flex-direction: column;
      gap: 12px;
      width: 100%;
      border: 1px solid #212121;
      border-radius: 8px;
      padding: 14px;
      background: rgba(255, 255, 255, 0.04);
      box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.05);
    }

    #modal5-container .recipe-card__picker.is-visible {
      display: flex;
    }

    #modal5-container .recipe-card__search {
      width: 100%;
      padding: 8px 10px;
      border-radius: 8px;
      border: 1px solid #212121;
      background: rgba(255, 255, 255, 0.08);
      color: var(--content-color, #212121);
      font-size: 12px;
      font-weight: 500;
    }

    #modal5-container .recipe-card__list {
      display: flex;
      flex-direction: column;
      gap: 8px;
      max-height: 240px;
      overflow-y: auto;
      padding-right: 4px;
    }

    #modal5-container .recipe-card__list::-webkit-scrollbar {
      width: 6px;
    }

    #modal5-container .recipe-card__list::-webkit-scrollbar-thumb {
      background: var(--content-color, #212121);
      border-radius: 10px;
    }

    /* НОВОЕ ПРАВИЛО начало */
    #modal5-container .recipe-card__body .modalColumn {
      flex: 1 1 100%;
      max-width: 100%;
    }
    /* НОВОЕ ПРАВИЛО конец */
    
    #modal5-container .recipe-card__workspace {
      position: relative;
      display: block;
      min-height: 270px;
      /* НОВОЕ свойство */
      width: 100%;
    }

    #modal5-container .recipe-card__items {
      display: flex;
      flex-direction: column;
      gap: 12px;
      position: relative;
      z-index: 1;
    }

    #modal5-container .recipe-item-row {
      border: 1px solid #212121;
      border-radius: 10px;
      padding: 14px 16px;
      background: rgba(255, 255, 255, 0.03);
      display: flex;
      flex-direction: column;
      gap: 12px;
      position: relative;
      overflow: visible;
    }

    #modal5-container .recipe-item-row .modalRow {
      margin-left: 0;
      align-items: center;
      gap: 14px;
    }

    #modal5-container .recipe-item-suggestions {
      position: absolute;
      left: 16px;
      right: 16px;
      top: calc(100% - 4px);
      z-index: 5;
      display: none;
      flex-direction: column;
      gap: 6px;
      padding: 10px;
      border-radius: 10px;
      background: rgba(255, 255, 255, 0.9);
      border: 1px solid rgba(33, 33, 33, 0.6);
      box-shadow:
        0 8px 18px rgba(0, 0, 0, 0.18),
        0 2px 8px rgba(0, 0, 0, 0.12);
      max-height: 260px;
      overflow-y: auto;
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
    }

    #modal5-container .recipe-item-suggestions.is-visible {
      display: flex;
    }

    #modal5-container .recipe-item-suggestions::-webkit-scrollbar {
      width: 6px;
    }

    #modal5-container .recipe-item-suggestions::-webkit-scrollbar-thumb {
      background: rgba(33, 33, 33, 0.6);
      border-radius: 10px;
    }

    #modal5-container .recipe-item-suggestion {
      display: flex;
      align-items: center;
      gap: 10px;
      border: 1px solid rgba(33, 33, 33, 0.65);
      border-radius: 8px;
      padding: 8px 10px;
      background: rgba(248, 248, 248, 0.92);
      color: #212121;
      font-size: 12px;
      font-weight: 600;
      text-transform: none;
      letter-spacing: 0.02em;
      cursor: pointer;
      transition: background 0.2s ease, transform 0.2s ease;
    }

    #modal5-container .recipe-item-suggestion:hover,
    #modal5-container .recipe-item-suggestion:focus {
      background: rgba(230, 230, 230, 0.95);
      transform: translateY(-1px);
      outline: none;
    }

    #modal5-container .recipe-item-suggestion__code {
      min-width: 90px;
      font-weight: 700;
    }

    #modal5-container .recipe-item-suggestion__name {
      flex: 1;
      font-weight: 500;
    }

    #modal5-container .recipe-item-suggestion__category {
      font-weight: 500;
      opacity: 0.75;
    }

    #modal5-container .recipe-item-suggestions__empty {
      font-size: 12px;
      font-weight: 500;
      text-align: center;
      color: rgba(33, 33, 33, 0.7);
      padding: 6px 0;
    }

    #modal5-container .recipe-picker__item {
      display: flex;
      justify-content: space-between;
      gap: 12px;
      align-items: center;
      border: 1px solid #212121;
      border-radius: 8px;
      padding: 8px 10px;
      background: rgba(255, 255, 255, 0.05);
      color: var(--content-color, #212121);
      cursor: pointer;
      transition: background 0.2s ease, transform 0.2s ease;
      font-size: 12px;
      text-align: left;
      outline: none;
      text-decoration: none;
    }

    #modal5-container .recipe-picker__item:hover,
    #modal5-container .recipe-picker__item:focus {
      background: rgba(255, 255, 255, 0.12);
      transform: translateY(-1px);
    }

    #modal5-container .recipe-picker__item span {
      pointer-events: none;
    }

    #modal5-container .recipe-picker__item span.recipe-picker__code {
      font-weight: 600;
      min-width: 90px;
    }

    #modal5-container .recipe-picker__item span.recipe-picker__name {
      flex: 1;
      white-space: normal;
    }

    #modal5-container .recipe-card__empty {
      font-size: 12px;
      opacity: 0.75;
      text-align: center;
      padding: 8px 0;
    }

    #modal5-container .button-remove {
      align-self: flex-end;
      display: inline-flex;
      align-items: center;
      gap: 6px;
      border: none;
      background: transparent;
      color: var(--content-color, #212121);
      cursor: pointer;
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      padding: 4px 6px;
      border-radius: 6px;
      transition: background 0.2s ease, color 0.2s ease;
    }

    #modal5-container .button-remove:hover,
    #modal5-container .button-remove:focus {
      background: rgba(255, 255, 255, 0.12);
    }

    #modal5-container .button-form.secondary {
      background: transparent;
      color: var(--content-color, #212121);
      border-color: #212121;
    }

    #modal5-container .button-form.secondary:hover {
      background: rgba(255, 255, 255, 0.12);
      color: var(--content-color, #212121);
    }

    #modal5-container .input--error {
      border-color: #c62828;
      box-shadow: 0 0 0 1px rgba(198, 40, 40, 0.35);
    }

    #modal5-container .inputT,
    #modal5-container .input,
    #modal5-container .inputSUM {
      padding: 8px 10px;
      border-radius: 8px;
      font-size: 12px;
      font-weight: 500;
      border: 1px solid #212121;
      outline: none;
      background: rgba(255, 255, 255, 0.08);
      color: var(--content-color, #212121);
      transition: border-color 0.3s ease, transform 0.2s ease;
      font-variant-numeric: tabular-nums;
    }

    #modal5-container .inputT:focus,
    #modal5-container .input:focus,
    #modal5-container .inputSUM:focus {
      border-color: var(--content-color, #30333C);
      background: rgba(255, 255, 255, 0.12);
    }

    #modal5-container .inputSUM {
      text-align: right;
      width: 116px;
    }

    #modal5-container .code-field { width: 130px; text-transform: uppercase; }
    #modal5-container .name-field { width: 340px; }
    #modal5-container .url-field { width: 200px; }
    #modal5-container .supplier-field { width: 220px; }
    #modal5-container .select-wrapper {
      width: 100px;
      position: relative;
    }

    #modal5-container .select-input {
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid rgba(255, 255, 255, 0.18);
      box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.05);
      transition: border-color 0.3s ease, background 0.3s ease;
    }

    #modal5-container .select-input:focus {
      background: rgba(255, 255, 255, 0.12);
      border-color: rgba(255, 255, 255, 0.32);
    }

    #modal5-container label.checkbox {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    #modal5-container .checkbox input[type="checkbox"] {
      appearance: none;
      width: 20px;
      height: 20px;
      border: 2px solid var(--content-color, #212121);
      border-radius: 4px;
      position: relative;
      cursor: pointer;
      background: transparent;
      transition: background 0.2s ease, transform 0.2s ease;
    }

    #modal5-container .checkbox input[type="checkbox"]:checked {
      background: var(--content-color, #212121);
    }

    #modal5-container .checkbox input[type="checkbox"]::after {
      content: '';
      position: absolute;
      top: 2px;
      left: 6px;
      width: 4px;
      height: 10px;
      border: solid #f5f5f5;
      border-width: 0 2px 2px 0;
      transform: rotate(45deg);
      opacity: 0;
      transition: opacity 0.2s ease;
    }

    #modal5-container .checkbox input[type="checkbox"]:checked::after {
      opacity: 1;
    }

    #modal5-container .recipe-notes {
      padding-left: 40px;
      font-size: 12px;
      line-height: 1.6;
      opacity: 0.85;
      color: var(--content-color, #212121);
    }

    #modal5-container .spec-icon {
      color: var(--content-color, #212121);
      font-size: 20px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: transform 0.2s ease, color 0.2s ease;
    }

    #modal5-container .spec-icon:hover {
      color: rgba(98, 90, 86, 0.85);
      transform: scale(1.05);
    }

    /* границы переключателя */
.switch {
  font-size: 1px;
  position: relative;
  display: inline-block;
  width: 54px;
  height: 30px;
  border: 1px solid #212121;
  border-radius: 6px;
  margin: 2px;
}

/* Hide default HTML checkbox */
.switch input {
  opacity: 0;
  width: 0;
  height: 0;
}

/* фон переключателя в выключенном состоянии */
.slider {
  position: absolute;
  cursor: pointer;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-color: #fffff;
  transition: .4s;
  border-radius: 6px;
}

.slider:before {
  position: absolute;
  content: "";
  height: 19px;
  width: 4px;
  border-radius: 10px;
  left: 4px;
  bottom: 4px;
  background-color: #212121;
  transition: .4s;
}

input:checked + .slider:before {
  transform: translateX(39px) rotate(360deg);
  background-color: #212121;
}

    
  </style>
  
  <div class="modal-top glass-panel">
    <section class="modal5-signature">
      <h2>
        <span>R</span>
        <span>I</span>
        <span>V</span>
        <span>A</span>
        <span>&nbsp;&nbsp;</span>
        <span>D</span>
        <span>E</span>
        <span>V</span>
        <span>E</span>
        <span>L</span>
        <span>O</span>
        <span>P</span>
        <span>M</span>
        <span>E</span>
        <span>N</span>
        <span>T</span>
        <span>&nbsp;&nbsp;</span>
        <span class="warehouse-letter">R</span>
        <span class="warehouse-letter">E</span>
        <span class="warehouse-letter">C</span>
        <span class="warehouse-letter">I</span>
        <span class="warehouse-letter">P</span>
        <span class="warehouse-letter">E</span>
        <span class="warehouse-letter">S</span>
        <span>&nbsp;&nbsp;</span>
        <span class="warehouse-letter">H</span>
        <span class="warehouse-letter">U</span>
        <span class="warehouse-letter">B</span>
      </h2>
    </section>

    <div class="modalRow form-row">
      <div class="modalBLOCK form-fields">
        <div class="modalRow" style="margin-left: -20px;">
            <input id="recipe-code" class="inputT code-field" type="text" placeholder="RCP-0001" autocomplete="off"/>
            <input id="recipe-name" class="input name-field" type="text" placeholder="наименование рецепта" autocomplete="off" />
            <input id="recipe-category" class="input name-field" type="text" placeholder="категория рецепта" autocomplete="off" />
          </div>
      </div>
      <button class="button-form primary" id="create-recipe" type="button">создать рецепт</button>
    </div>
  </div>

  <div class="modal5-scroll-wrapper">
    <div class="modal-bottom glass-panel modal5-window">
      <div class="modalVNUT-content modal5-content" id="recipe-list"></div>

        <template id="recipe-card-template">
        <div class="recipe-card" data-recipe-id="" style="width: 1890px;">
          <div class="modalRow recipe-card__header" style="margin-top: 0px; padding-top: 2px;">
            <input class="inputT code-field" data-field="recipe_code" readonly />
            <input class="input name-field" data-field="recipe_name" readonly />
            <input class="input name-field" data-field="recipe_category" readonly />
            <div class="input date-time-field" style="width: 200px;" data-field="date-time" aria-label="дата и время">
              <span class="date-time-field__time"></span>
              <span class="date-time-field__date"></span>
            </div>
            <button class="button-form secondary recipe-card__delete" style="margin-left: 0px; position: relative;" type="button">удалить рецепт</button>
          </div>
          
          <div class="recipe-card__body">
  <div class="modalRow">
    <div class="modalColumn">
            <div class="recipe-card__controls" style="height: 30px; width: 1570px;">
              <div class="modalRow recipe-card__header" style="margin-top: 0px; height: 30px;">
                <button class="button-form primary recipe-card__add" type="button">добавить позицию</button>
                <input class="inputSUM recipe-card__total" style="width: 140px; margin-left: 660px; background: #212121; color: #ffffff; text-transform: uppercase; font-weight: 700;" placeholder="000 000 000" readonly />
                <label class="switch">
                   <input class="recipe-card__manufacture-toggle" type="checkbox">
                   <span class="slider"></span>
                </label>
                <div class="modalRow recipe-card__manufacture-controls" hidden aria-hidden="true">
                   <input class="inputSUM recipe-card__manufacture-multiplier" style="width: 70px; height: 30px; text-align: center; font-weight: 700;" placeholder="000 000"/>
                   <button class="button-form primary" type="button">изготовить товары</button>
                </div>
              </div>
              <div class="recipe-card__picker" aria-hidden="true">
                <input class="recipe-card__search" type="search" placeholder="Поиск по коду или наименованию" />
                <div class="recipe-card__list"></div>
                <button class="button-form secondary recipe-card__picker-close" type="button">закрыть</button>
              </div>
            </div>      
  <div class="modalRow">
    <div class="modalColumn">
            <div class="recipe-card__workspace">
              <div class="recipe-card__common-notes" aria-hidden="false">
                <textarea class="input recipe-card__common-notes-textarea" placeholder="введите общие заметки по рецепту" aria-label="общие заметки по рецепту"></textarea>
              </div>
              <div class="recipe-card__items"></div>
            </div>
    </div>


    
  </div>
     </div>
  </div>
          </div>

          <div class="recipe-card__visual" style="width: 300px; padding-bottom: 20px;">
              <div class="recipe-visual-card">
                <div class="recipe-visual-card__inner">
                  <div class="recipe-visual-card__box">
                    <div class="recipe-visual-card__image">
                      <img src="https://images.unsplash.com/photo-1601049676869-702ea24cfd58?q=80&w=2073&auto=format&fit=crop&ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D" data-placeholder="https://images.unsplash.com/photo-1601049676869-702ea24cfd58?q=80&w=2073&auto=format&fit=crop&ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D" alt="визуал рецепта">
                    </div>
                    <div class="recipe-visual-card__footer">
                      <!-- <h3>визуал рецепта</h3> -->
                      <button class="recipe-visual-card__button" style="margin-left: 10px;" type="button">загрузить</button>
                      <input class="recipe-visual-card__input" type="file" accept="image/*" aria-label="загрузить изображение рецепта" />
                    </div>
                  </div>
                </div>
              </div>
            </div>
        </div>
      </template>

      <template id="recipe-item-template">
        <div class="recipe-item-row" style="width: 1570px; padding: 0px; border: none" data-item-id="">
          <div class="modalRow">
            <input class="inputT code-field" data-field="order_code" style="width: 110px;" placeholder="RIV-0881" />
            <input class="input name-field" data-field="item_name" style="width: 280px;" placeholder="наименование" />
            <input class="input category-field" data-field="item_category" style="width: 200px;" placeholder="категория" />
            <input class="input" style="width: 60px; text-align: center;" data-field="base_unit" placeholder="изм." readonly />
            <input class="inputSUM" style="width: 70px;" data-field="base_qty" placeholder="000 000" />
            <input class="inputSUM" style="width: 70px;" data-field="base_price" placeholder="000 000 000" readonly />
            <input class="inputSUM" style="width: 100px;" data-field="total" placeholder="000 000 000" readonly />
            <button class="button-remove" type="button"><i class="material-symbols-outlined">delete</i></button>
            <input class="inputSUM recipe-card__manufacture-result" style="width: 70px; height: 30px;" placeholder="000 000" hidden aria-hidden="true" readonly />
            <div class="recipe-card__manufacture-chart" hidden aria-hidden="true">
              <div class="manufacture-chart__grid" aria-hidden="true"></div>
            </div>
            <input class="inputSUM recipe-card__manufacture-balance" style="width: 70px; height: 30px;" placeholder="000 000" hidden aria-hidden="true" readonly />
          </div>
          <div class="recipe-item-suggestions" aria-hidden="true"></div>
        </div>
      </template>

    </div>
  </div>
</div>
<script type="module">

  const MONTHS_RU = [
  'января',
  'февраля',
  'марта',
  'апреля',
  'мая',
  'июня',
  'июля',
  'августа',
  'сентября',
  'октября',
  'ноября',
  'декабря',
];
  
export function initModal5() {
  const modal = document.getElementById('modal5-container');
  if (!modal) return;

  const supabaseClient = window.supabase ?? null;

  const recipeCodeInput = modal.querySelector('#recipe-code');
  const recipeCategoryInput = modal.querySelector('#recipe-category');
  const recipeNameInput = modal.querySelector('#recipe-name');
  const createButton = modal.querySelector('#create-recipe');
  const recipeList = modal.querySelector('#recipe-list');
  const cardTemplate = modal.querySelector('#recipe-card-template');
  const itemTemplate = modal.querySelector('#recipe-item-template');

  if (!(recipeCodeInput instanceof HTMLInputElement)
    || !(recipeCategoryInput instanceof HTMLInputElement)
    || !(recipeNameInput instanceof HTMLInputElement)
    || !(createButton instanceof HTMLButtonElement)
    || !(recipeList instanceof HTMLElement)
    || !(cardTemplate instanceof HTMLTemplateElement)
    || !(itemTemplate instanceof HTMLTemplateElement)) {
    console.warn('[modal5.html] не найдены необходимые элементы для работы рецептов');
    return;
  }
  
  const RECIPES_TABLE = 'modal5_recipes';
  const RECIPE_IMAGE_BUCKET = 'modal5_recipe_images';
  const rawUserKey = window.USER_KEY ?? null;
  const authUserId = window.AUTH_ID ?? null;
  const DB_USER_KEY = authUserId || rawUserKey;
  let DB_COMPANY_ID = window.companyId || window.companyID || null;
  let resolvingCompanyIdPromise = null;
  const cardSaveTimers = new WeakMap();
  const cardSaveChains = new WeakMap();
  const cardImageState = new WeakMap();

  const resolveCompanyId = async () => {
    if (DB_COMPANY_ID) return DB_COMPANY_ID;
    if (!supabaseClient) return null;
    if (resolvingCompanyIdPromise) return resolvingCompanyIdPromise;

    const localId = window.LOCAL_USER_ID;
    const isAdmin = Boolean(window.IS_ADMIN);
    const tablesToCheck = isAdmin
      ? ['administrators', 'employees']
      : ['employees', 'administrators'];

    resolvingCompanyIdPromise = (async () => {
      for (const table of tablesToCheck) {
        try {
          let query = supabaseClient
            .from(table)
            .select('company_id')
            .limit(1);

          if (localId) {
            query = query.eq('id', localId);
          } else if (DB_USER_KEY) {
            query = query.eq('user_key', DB_USER_KEY);
          } else if (rawUserKey) {
            query = query.eq('user_key', rawUserKey);
          } else {
            continue;
          }

          const { data, error } = await query;
          if (error) {
            console.warn(`[modal5.html] не удалось получить company_id из ${table}:`, error);
            continue;
          }

          if (Array.isArray(data) && data.length) {
            const companyId = data[0]?.company_id ?? null;
            if (companyId) {
              DB_COMPANY_ID = companyId;
              if (!window.companyId) window.companyId = companyId;
              return companyId;
            }
          }
        } catch (err) {
          console.warn(`[modal5.html] исключение при получении company_id из ${table}:`, err);
        }
      }

      return DB_COMPANY_ID;
    })();

    try {
      return await resolvingCompanyIdPromise;
    } finally {
      resolvingCompanyIdPromise = null;
    }
  };


  let stockItems = [];
  let stockMap = new Map();
  let stockCodeMap = new Map();
  let stocksLoaded = false;
  let isLoadingStocks = false;
  let refreshTimerId = null;
  const latestOrderCache = new Map();
  const MAX_SUGGESTIONS = 20;

  const normalizeOrderCode = code => {
    if (typeof code !== 'string') return '';
    return code.trim().toLowerCase();
  };

  const getStockByOrderCode = code => {
    const normalized = normalizeOrderCode(code);
    if (!normalized) return null;
    return stockCodeMap.get(normalized) ?? null;
  };

  const getRowStoredTotalQuantity = row => {
    if (!(row instanceof HTMLElement)) return null;
    if (!('totalQuantity' in row.dataset)) return null;
    const parsed = parseNumber(row.dataset.totalQuantity);
    return parsed !== null ? parsed : null;
  };

  const MANUFACTURE_CHART_CELL_COUNT = 40;

  const clamp01 = value => {
    const number = typeof value === 'number' ? value : 0;
    if (!Number.isFinite(number)) return 0;
    return Math.min(Math.max(number, 0), 1);
  };

  const ensureManufactureGrid = chart => {
    if (!(chart instanceof HTMLElement)) return [];
    const grid = chart.querySelector('.manufacture-chart__grid');
    if (!(grid instanceof HTMLElement)) return [];

    if (grid.children.length !== MANUFACTURE_CHART_CELL_COUNT) {
      grid.innerHTML = '';
      for (let index = 0; index < MANUFACTURE_CHART_CELL_COUNT; index += 1) {
        const cell = document.createElement('div');
        cell.className = 'manufacture-chart__cell';
        cell.setAttribute('aria-hidden', 'true');

        const fill = document.createElement('div');
        fill.className = 'manufacture-chart__cell-fill';

        const overflow = document.createElement('div');
        overflow.className = 'manufacture-chart__cell-overflow';

        cell.append(fill, overflow);
        grid.appendChild(cell);
      }
    }

    return Array.from(grid.children).filter(child => child instanceof HTMLElement);
  };

  const resetRowManufactureChart = row => {
    if (!(row instanceof HTMLElement)) return;
    const chart = row.querySelector('.recipe-card__manufacture-chart');
    if (!(chart instanceof HTMLElement)) return;
    const cells = ensureManufactureGrid(chart);
    cells.forEach(cell => {
      if (cell instanceof HTMLElement) {
        cell.style.setProperty('--fill', '0');
        cell.style.setProperty('--overflow', '0');
        cell.setAttribute('aria-hidden', 'true');
      }
    });
  };

  const updateRowManufactureChart = (row, { visible = false, totalQuantity = null, requiredQty = null } = {}) => {
    if (!(row instanceof HTMLElement)) return;
    const chart = row.querySelector('.recipe-card__manufacture-chart');
    const balanceField = row.querySelector('.recipe-card__manufacture-balance');
    if (!(chart instanceof HTMLElement)) {
      if (balanceField instanceof HTMLInputElement) {
        balanceField.value = '';
        balanceField.hidden = true;
        balanceField.setAttribute('aria-hidden', 'true');
        balanceField.classList.remove('is-overflow');
      }
      return;
    }

    resetRowManufactureChart(row);

    if (!visible) {
      chart.hidden = true;
      chart.setAttribute('aria-hidden', 'true');
      if (balanceField instanceof HTMLInputElement) {
        balanceField.value = '';
        balanceField.hidden = true;
        balanceField.setAttribute('aria-hidden', 'true');
        balanceField.classList.remove('is-overflow');
      }
      return;
    }

    chart.hidden = false;
    chart.setAttribute('aria-hidden', 'false');

    if (balanceField instanceof HTMLInputElement) {
      balanceField.hidden = false;
      balanceField.setAttribute('aria-hidden', 'false');
    }

    const hasTotal = typeof totalQuantity === 'number' && Number.isFinite(totalQuantity);
    const hasRequired = typeof requiredQty === 'number' && Number.isFinite(requiredQty);
    const safeTotal = hasTotal ? Math.max(totalQuantity, 0) : 0;
    const safeRequired = hasRequired ? Math.max(requiredQty, 0) : 0;

    const cells = ensureManufactureGrid(chart);
    cells.forEach(cell => {
      if (cell instanceof HTMLElement) {
        cell.setAttribute('aria-hidden', 'false');
      }
    });

    let baseRatio = 0;
    let overflowRatio = 0;

    if (hasRequired) {
      if (hasTotal && safeTotal > 0) {
        const ratio = safeRequired / safeTotal;
        baseRatio = Math.min(ratio, 1);
        overflowRatio = Math.max(ratio - 1, 0);
      } else if (safeRequired > 0) {
        baseRatio = 0;
        overflowRatio = 1;
      }
    }

    const baseCells = baseRatio * MANUFACTURE_CHART_CELL_COUNT;
    const overflowCells = overflowRatio * MANUFACTURE_CHART_CELL_COUNT;

    const baseFilledCount = Math.min(
      Math.floor(baseCells),
      MANUFACTURE_CHART_CELL_COUNT
    );
    const overflowFilledCount = Math.min(
      Math.floor(overflowCells),
      MANUFACTURE_CHART_CELL_COUNT
    );

    cells.forEach((cell, index) => {
      if (!(cell instanceof HTMLElement)) return;
      const isBaseFilled = index < baseFilledCount;
      const isOverflowFilled = index >= MANUFACTURE_CHART_CELL_COUNT - overflowFilledCount;
      cell.style.setProperty('--fill', isBaseFilled ? '1' : '0');
      cell.style.setProperty('--overflow', isOverflowFilled ? '1' : '0');
    });

    if (balanceField instanceof HTMLInputElement) {
      let balanceValue = '';
      let isOverflowBalance = false;

    if (hasRequired && hasTotal) {
        const balance = totalQuantity - requiredQty;
        if (Number.isFinite(balance)) {
          if (balance >= 0) {
            balanceValue = fmtNum(balance, { maximumFractionDigits: 3 });
          } else {
            balanceValue = fmtNum(Math.abs(balance), { maximumFractionDigits: 3 });
            isOverflowBalance = true;
          }
        }
      } else if (hasRequired && safeRequired > 0) {
        balanceValue = fmtNum(safeRequired, { maximumFractionDigits: 3 });
        isOverflowBalance = true;
      }

      balanceField.value = balanceValue;
      balanceField.classList.toggle('is-overflow', isOverflowBalance);
    }
  };


  const getSuggestionsContainer = row =>
    row instanceof HTMLElement ? row.querySelector('.recipe-item-suggestions') : null;

  const hideRowSuggestions = row => {
    const container = getSuggestionsContainer(row);
    if (!(container instanceof HTMLElement)) return;
    container.innerHTML = '';
    container.classList.remove('is-visible');
    container.setAttribute('aria-hidden', 'true');
  };

  const ensureSuggestionContainer = row => {
    const container = getSuggestionsContainer(row);
    if (!(container instanceof HTMLElement)) return;
    if (container.dataset.bound === '1') return;
    container.addEventListener('mousedown', event => {
      event.preventDefault();
    });
    container.dataset.bound = '1';
  };

  const scheduleHideSuggestions = row => {
    if (!(row instanceof HTMLElement)) return;
    setTimeout(() => {
      const active = document.activeElement;
      if (active instanceof Node && row.contains(active)) return;
      hideRowSuggestions(row);
    }, 120);
  };

  const clearRowStockData = row => {
    if (!(row instanceof HTMLElement)) return;
    row.dataset.itemId = '';
    row.dataset.price = '';
    delete row.dataset.totalQuantity;
    const baseUnit = row.querySelector('[data-field="base_unit"]');
    if (baseUnit instanceof HTMLInputElement) {
      baseUnit.value = '';
    }
    const priceInput = row.querySelector('[data-field="base_price"]');
    if (priceInput instanceof HTMLInputElement) {
      priceInput.value = '';
      delete priceInput.dataset.raw;
    }
    const totalInput = row.querySelector('[data-field="total"]');
    if (totalInput instanceof HTMLInputElement) {
      totalInput.value = '';
    }
    updateRowManufactureChart(row, { visible: false });
    const card = row.closest('.recipe-card');
    if (card instanceof HTMLElement) {
      updateCardTotal(card);
      updateManufactureOutputs(card);
    }
  };

  const renderRowSuggestions = (card, row, items) => {
    const container = getSuggestionsContainer(row);
    if (!(container instanceof HTMLElement)) return;
    container.innerHTML = '';

    const limited = items.slice(0, MAX_SUGGESTIONS);
    if (!limited.length) {
      const empty = document.createElement('div');
      empty.className = 'recipe-item-suggestions__empty';
      empty.textContent = 'Позиции не найдены';
      container.appendChild(empty);
      container.classList.add('is-visible');
      container.setAttribute('aria-hidden', 'false');
      return;
    }

    limited.forEach(item => {
      const button = document.createElement('button');
      button.type = 'button';
      button.className = 'recipe-item-suggestion';
      const codeSpan = document.createElement('span');
      codeSpan.className = 'recipe-item-suggestion__code';
      codeSpan.textContent = item.order_code;
      const nameSpan = document.createElement('span');
      nameSpan.className = 'recipe-item-suggestion__name';
      nameSpan.textContent = item.item_name;
      const categorySpan = document.createElement('span');
      categorySpan.className = 'recipe-item-suggestion__category';
      categorySpan.textContent = item.item_category;
      button.append(codeSpan, nameSpan, categorySpan);
      button.addEventListener('click', () => {
        addItemToCard(card, item, { targetRow: row });
        hideRowSuggestions(row);
        const qtyInput = row.querySelector('[data-field="base_qty"]');
        if (qtyInput instanceof HTMLInputElement) {
          qtyInput.focus();
        }
      });
      container.appendChild(button);
    });

    container.classList.add('is-visible');
    container.setAttribute('aria-hidden', 'false');
  };

  const fmtNum = (value, { minimumFractionDigits = 0, maximumFractionDigits = minimumFractionDigits } = {}) => {
    if (value === null || value === undefined || value === '') return '';
    const num = Number(value);
    if (!Number.isFinite(num)) return '';
    const maxDigits = Math.max(minimumFractionDigits, maximumFractionDigits);
    return num.toLocaleString('ru-RU', {
      minimumFractionDigits,
      maximumFractionDigits: maxDigits,
    });
  };

  const parseNumber = value => {
    if (value === null || value === undefined) return null;
    const normalized = String(value)
      .replace(/[\s\u202f]/g, '')
      .replace(',', '.')
      .trim();
    if (!normalized) return null;
    const parsed = Number(normalized);
    return Number.isFinite(parsed) ? parsed : null;
  };

  const numberToStorageString = value => {
    if (value === null || value === undefined) return '';
    const numeric = Number(value);
    return Number.isFinite(numeric) ? String(numeric) : '';
  };

  const getCardFieldValue = (card, field) => {
    if (!(card instanceof HTMLElement)) return '';
    const input = card.querySelector(`[data-field="${field}"]`);
    return input instanceof HTMLInputElement ? input.value.trim() : '';
  };

  const getRowFieldValue = (row, field) => {
    if (!(row instanceof HTMLElement)) return '';
    const input = row.querySelector(`[data-field="${field}"]`);
    return input instanceof HTMLInputElement ? input.value.trim() : '';
  };

  const fetchLatestOrderSnapshot = async (orderCode, { companyId } = {}) => {
    const normalized = String(orderCode ?? '').trim();
    if (!normalized || !supabaseClient) return null;
    const cacheKey = `${companyId || 'none'}::${normalized.toLowerCase()}`;
    if (latestOrderCache.has(cacheKey)) {
      try {
        return await latestOrderCache.get(cacheKey);
      } catch (err) {
        latestOrderCache.delete(cacheKey);
        throw err;
      }
    }

    const loader = (async () => {
      try {
        let query = supabaseClient
          .from('modal4_orders')
          .select('order_code, item_name, item_category, url, supplier, modification, status')
          .eq('order_code', normalized)
          .order('created_at', { ascending: false })
          .limit(1);

        if (companyId) {
          query = query.eq('company_id', companyId);
        } else if (DB_USER_KEY) {
          query = query.eq('user_key', DB_USER_KEY);
        }

        const { data, error } = await query;
        if (error) {
          console.error(`[modal5.html] ошибка получения modal4_orders по коду ${normalized}:`, error);
          return null;
        }

        if (Array.isArray(data) && data.length) {
          return data[0];
        }

        return null;
      } catch (err) {
        console.error(`[modal5.html] исключение при получении modal4_orders по коду ${normalized}:`, err);
        return null;
      }
    })();

    latestOrderCache.set(cacheKey, loader);

    try {
      const result = await loader;
      latestOrderCache.set(cacheKey, Promise.resolve(result));
      return result;
    } catch (err) {
      latestOrderCache.delete(cacheKey);
      throw err;
    }
  };

  const updateCardTotal = card => {
    if (!(card instanceof HTMLElement)) return;
    const totalField = card.querySelector('.recipe-card__total');
    if (!(totalField instanceof HTMLInputElement)) return;
    const totalInputs = card.querySelectorAll('[data-field="total"]');
    let sum = 0;
    let hasValue = false;
    totalInputs.forEach(input => {
      if (!(input instanceof HTMLInputElement)) return;
      const value = parseNumber(input.value);
      if (value === null) return;
      sum += value;
      hasValue = true;
    });
    totalField.value = hasValue
      ? fmtNum(sum, { minimumFractionDigits: 2, maximumFractionDigits: 2 })
      : '';
  };

  const updateManufactureOutputs = card => {
    if (!(card instanceof HTMLElement)) return;
    const toggle = card.querySelector('.recipe-card__manufacture-toggle');
    const controls = card.querySelector('.recipe-card__manufacture-controls');
    const multiplierInput = controls?.querySelector('.recipe-card__manufacture-multiplier');
    const commonNotes = card.querySelector('.recipe-card__common-notes');
    const commonNotesInput = commonNotes?.querySelector('.recipe-card__common-notes-textarea');
    const enabled = toggle instanceof HTMLInputElement ? toggle.checked : false;
    const multiplier = enabled && multiplierInput instanceof HTMLInputElement
      ? parseNumber(multiplierInput.value)
      : null;

    if (commonNotes instanceof HTMLElement) {
      commonNotes.hidden = enabled;
      commonNotes.classList.toggle('is-hidden', enabled);
      commonNotes.setAttribute('aria-hidden', enabled ? 'true' : 'false');
      if (commonNotesInput instanceof HTMLTextAreaElement) {
        commonNotesInput.disabled = enabled;
      }
    }

    const rows = card.querySelectorAll('.recipe-item-row');
    rows.forEach(row => {
      if (!(row instanceof HTMLElement)) return;
      const resultField = row.querySelector('.recipe-card__manufacture-result');
      if (!(resultField instanceof HTMLInputElement)) return;

      if (!enabled) {
        resultField.value = '';
        resultField.hidden = true;
        resultField.setAttribute('aria-hidden', 'true');
        updateRowManufactureChart(row, { visible: false });
        return;
      }

      resultField.hidden = false;
      resultField.setAttribute('aria-hidden', 'false');

      const qtyInput = row.querySelector('[data-field="base_qty"]');
      const baseQty = qtyInput instanceof HTMLInputElement
        ? (qtyInput.dataset.raw ? parseNumber(qtyInput.dataset.raw) : parseNumber(qtyInput.value))
        : null;

      const product = baseQty !== null && multiplier !== null
        ? baseQty * multiplier
        : null;

      resultField.value = product !== null
        ? fmtNum(product, { minimumFractionDigits: 0, maximumFractionDigits: 3 })
        : '';

      const orderInput = row.querySelector('[data-field="order_code"]');
      const orderCode = orderInput instanceof HTMLInputElement ? orderInput.value : '';
      let totalQuantity = getRowStoredTotalQuantity(row);
      if (totalQuantity === null && orderCode) {
        const stock = getStockByOrderCode(orderCode);
        if (stock && typeof stock.total_quantity === 'number' && Number.isFinite(stock.total_quantity)) {
          totalQuantity = stock.total_quantity;
          row.dataset.totalQuantity = String(totalQuantity);
        }
      }

      updateRowManufactureChart(row, {
        visible: true,
        totalQuantity,
        requiredQty: product,
      });
    });
  };

  const formatDateTime = value => {
    if (!value) return { time: '', date: '' };
    const date = value instanceof Date ? value : new Date(value);
    if (Number.isNaN(date.getTime())) return { time: '', date: '' };
    const hours = String(date.getHours()).padStart(2, '0');
    const minutes = String(date.getMinutes()).padStart(2, '0');
    const day = String(date.getDate()).padStart(2, '0');
    const month = MONTHS_RU[date.getMonth()] ?? '';
    const year = date.getFullYear();
    return {
      time: `${hours}:${minutes}`,
      date: month ? `${day} ${month} ${year} г.` : '',
    };
  };

  const applyDateTime = (target, value) => {
    if (!(target instanceof HTMLElement)) return;
    const { time, date } = formatDateTime(value);
    const timeEl = target.querySelector('.date-time-field__time');
    const dateEl = target.querySelector('.date-time-field__date');
    if (timeEl) timeEl.textContent = time;
    if (dateEl) dateEl.textContent = date;
    target.dataset.time = time;
    target.dataset.date = date;
  };

  const toIsoString = value => {
    if (!value) return new Date().toISOString();
    if (value instanceof Date) return value.toISOString();
    const date = new Date(value);
    if (Number.isNaN(date.getTime())) return new Date().toISOString();
    return date.toISOString();
  };

  const collectCardState = card => {
    if (!(card instanceof HTMLElement)) return null;
    const getHeaderValue = field => {
      const input = card.querySelector(`[data-field="${field}"]`);
      return input instanceof HTMLInputElement ? input.value.trim() : '';
    };

    const createdAtIso = toIsoString(card.dataset.createdAt || new Date());
    const imageUrl = card.dataset.imageUrl ? card.dataset.imageUrl : '';

    const rows = Array.from(card.querySelectorAll('.recipe-item-row'));
    const items = rows.map((row, index) => {
      if (!(row instanceof HTMLElement)) return null;

      const getFieldValue = field => {
        const input = row.querySelector(`[data-field="${field}"]`);
        return input instanceof HTMLInputElement ? input.value.trim() : '';
      };

      const qtyInput = row.querySelector('[data-field="base_qty"]');
      const qtyRaw = qtyInput instanceof HTMLInputElement
        ? (qtyInput.dataset.raw ? parseNumber(qtyInput.dataset.raw) : parseNumber(qtyInput.value))
        : null;

      const priceInput = row.querySelector('[data-field="base_price"]');
      const priceRaw = priceInput instanceof HTMLInputElement
        ? (priceInput.dataset.raw ? parseNumber(priceInput.dataset.raw) : parseNumber(priceInput.value))
        : null;

      const normalizedQty = typeof qtyRaw === 'number' && Number.isFinite(qtyRaw) ? qtyRaw : null;
      const normalizedPrice = typeof priceRaw === 'number' && Number.isFinite(priceRaw) ? priceRaw : null;
      const checkbox = row.querySelector('input[type="checkbox"]');
      const checked = checkbox instanceof HTMLInputElement ? checkbox.checked : false;
      const total = normalizedQty !== null && normalizedPrice !== null
        ? normalizedQty * normalizedPrice
        : null;

      return {
        position: index,
        stock_id: row.dataset.itemId || null,
        order_code: getFieldValue('order_code'),
        item_name: getFieldValue('item_name'),
        item_category: getFieldValue('item_category'),
        base_unit: getFieldValue('base_unit'),
        base_qty: normalizedQty,
        base_price: normalizedPrice,
        total,
        checked,
      };
    }).filter(Boolean);

    return {
      id: card.dataset.recipeId || null,
      code: getHeaderValue('recipe_code'),
      category: getHeaderValue('recipe_category'),
      name: getHeaderValue('recipe_name'),
      createdAt: createdAtIso,
      image: imageUrl ? { url: imageUrl } : null,
      items,
    };
  };

  const computeCardStateHash = state => {
    if (!state) return '';
    return JSON.stringify({
      code: state.code ?? '',
      category: state.category ?? '',
      name: state.name ?? '',
      image: state.image?.url ?? '',
      items: state.items.map(item => ({
        position: item.position ?? 0,
        stock_id: item.stock_id ?? null,
        order_code: item.order_code ?? '',
        item_name: item.item_name ?? '',
        item_category: item.item_category ?? '',
        base_unit: item.base_unit ?? '',
        base_qty: item.base_qty ?? null,
        base_price: item.base_price ?? null,
        checked: Boolean(item.checked),
      })),
    });
  };

  const captureCardStateHash = card => {
    const state = collectCardState(card);
    if (!state) return '';
    const hash = computeCardStateHash(state);
    card.dataset.lastSavedState = hash;
    if (!card.dataset.createdAt && state.createdAt) {
      card.dataset.createdAt = state.createdAt;
    }
    return hash;
  };

  const persistRecipeCard = async card => {
    if (!supabaseClient) return;
    if (!(card instanceof HTMLElement)) return;

    const state = collectCardState(card);
    if (!state) return;

    const stateHash = computeCardStateHash(state);
    const existingId = state.id;
    const lastHash = card.dataset.lastSavedState || '';
    if (existingId && lastHash === stateHash) return;

    const companyId = await resolveCompanyId();
    if (!companyId) return;

    const payload = {
      recipe_code: state.code,
      recipe_category: state.category,
      recipe_name: state.name,
      items: state.items,
      updated_at: new Date().toISOString(),
      company_id: companyId,
      user_key: DB_USER_KEY ?? null,
    };

    // URL изображения больше не сохраняется в таблице —
    // при необходимости он подгружается напрямую из бакета Supabase.

    try {
      if (!existingId) {
        const createdAtIso = state.createdAt || new Date().toISOString();
        payload.created_at = createdAtIso;
        const { data, error } = await supabaseClient
          .from(RECIPES_TABLE)
          .insert(payload)
          .select()
          .single();

        if (error) {
          console.error('[modal5.html] ошибка создания рецепта:', error);
          return;
        }

        const created = data ?? null;
        if (created) {
          card.dataset.recipeId = created.id ?? '';
          const appliedCreatedAt = created.created_at ?? createdAtIso;
          card.dataset.createdAt = appliedCreatedAt;
          const dateField = card.querySelector('[data-field="date-time"]');
          if (dateField) applyDateTime(dateField, appliedCreatedAt);
          const rows = card.querySelectorAll('.recipe-item-row');
          rows.forEach(row => {
            if (row instanceof HTMLElement) {
              row.dataset.recipeId = card.dataset.recipeId;
            }
          });
        }
      } else {
        const { data, error } = await supabaseClient
          .from(RECIPES_TABLE)
          .update(payload)
          .eq('id', existingId)
          .eq('company_id', companyId)
          .select()
          .single();

        if (error) {
          console.error(`[modal5.html] ошибка обновления рецепта ${existingId}:`, error);
          return;
        }

        if (data?.updated_at) {
          card.dataset.updatedAt = data.updated_at;
        }
        const rows = card.querySelectorAll('.recipe-item-row');
        rows.forEach(row => {
          if (row instanceof HTMLElement) {
            row.dataset.recipeId = card.dataset.recipeId;
          }
        });
      }

      card.dataset.lastSavedState = stateHash;
    } catch (err) {
      console.error('[modal5.html] исключение при сохранении рецепта:', err);
    }
  };

  const queueSaveRecipe = (card, { immediate = false } = {}) => {
    if (!supabaseClient) return;
    if (!(card instanceof HTMLElement)) return;
    const existingTimer = cardSaveTimers.get(card);
    if (existingTimer) {
      clearTimeout(existingTimer);
    }

    const delay = immediate ? 0 : 800;
    const timer = setTimeout(() => {
      cardSaveTimers.delete(card);
      const chain = cardSaveChains.get(card) ?? Promise.resolve();
      const next = chain.then(() => persistRecipeCard(card));
      cardSaveChains.set(card, next.catch(err => {
        console.error('[modal5.html] ошибка сохранения рецепта:', err);
      }));
    }, delay);

    cardSaveTimers.set(card, timer);
  };

  const cancelQueuedSave = card => {
    const timer = cardSaveTimers.get(card);
    if (timer) {
      clearTimeout(timer);
      cardSaveTimers.delete(card);
    }
  };

  const deleteRecipeById = async recipeId => {
    if (!supabaseClient || !recipeId) return;
    try {
      const companyId = await resolveCompanyId();
      if (!companyId) return;
      const { error } = await supabaseClient
        .from(RECIPES_TABLE)
        .delete()
        .eq('id', recipeId)
        .eq('company_id', companyId);

      if (error) {
        console.error(`[modal5.html] ошибка удаления рецепта ${recipeId}:`, error);
      }
    } catch (err) {
      console.error(`[modal5.html] исключение при удалении рецепта ${recipeId}:`, err);
    }
  };


  const normalizeStockRow = row => {
    if (!row) return null;
    const id = row.id ?? row.order_code ?? row.item_name;
    if (!id) return null;
    const price = parseNumber(row.avg_cost);
    const totalQuantity = parseNumber(row.total_quantity);
    const stockValue = parseNumber(row.stock_value);
    return {
      id: String(id),
      order_code: row.order_code ?? '',
      item_name: row.item_name ?? '',
      item_category: row.item_category ?? '',
      base_unit: row.base_unit ?? '',
      price: price ?? null,
      total_quantity: totalQuantity ?? null,
      stock_value: stockValue ?? null,
      url: row.url ?? '',
      supplier: row.supplier ?? '',
    };
  };

  const filterStockItems = query => {
    const normalized = String(query ?? '').trim().toLowerCase();
    if (!normalized) return stockItems;
    return stockItems.filter(item =>
      item.order_code.toLowerCase().includes(normalized)
      || item.item_name.toLowerCase().includes(normalized)
      || item.item_category.toLowerCase().includes(normalized));
  };

  const applyStockFields = (row, stock) => {
    if (!(row instanceof HTMLElement) || !stock) return;
    const setField = (field, value) => {
      const target = row.querySelector(`[data-field="${field}"]`);
      if (target instanceof HTMLInputElement) {
        target.value = value ?? '';
      }
    };
    setField('order_code', stock.order_code);
    setField('item_name', stock.item_name);
    setField('item_category', stock.item_category);
    setField('base_unit', stock.base_unit);

    const priceInput = row.querySelector('[data-field="base_price"]');
    const price = Number.isFinite(stock.price) ? stock.price : null;
    if (priceInput instanceof HTMLInputElement) {
      if (price !== null) {
        priceInput.dataset.raw = String(price);
        priceInput.value = fmtNum(price, { minimumFractionDigits: 2, maximumFractionDigits: 2 });
      } else {
        priceInput.value = '';
        delete priceInput.dataset.raw;
      }
    }
    row.dataset.price = price !== null ? String(price) : '';

    const totalQuantity = typeof stock.total_quantity === 'number' && Number.isFinite(stock.total_quantity)
      ? stock.total_quantity
      : null;
    if (totalQuantity !== null) {
      row.dataset.totalQuantity = String(totalQuantity);
    } else {
      delete row.dataset.totalQuantity;
    }

    const card = row.closest('.recipe-card');
    if (card instanceof HTMLElement) {
      updateManufactureOutputs(card);
    }
  };

  const getRowPrice = row => {
    if (!(row instanceof HTMLElement)) return null;
    let price = parseNumber(row.dataset.price ?? '');
    if (price !== null) return price;
    const priceInput = row.querySelector('[data-field="base_price"]');
    if (priceInput instanceof HTMLInputElement) {
      price = parseNumber(priceInput.dataset.raw ?? priceInput.value);
    }
    return price;
  };

  const updateTotalUsingRaw = (row, qtyRaw, { formatQty = false } = {}) => {
    if (!(row instanceof HTMLElement)) return;
    const qtyInput = row.querySelector('[data-field="base_qty"]');
    const totalInput = row.querySelector('[data-field="total"]');

    if (qtyInput instanceof HTMLInputElement && formatQty) {
      if (qtyRaw === null) {
        qtyInput.value = '';
        delete qtyInput.dataset.raw;
      } else {
        qtyInput.dataset.raw = String(qtyRaw);
        qtyInput.value = fmtNum(qtyRaw, { maximumFractionDigits: 3 });
      }
    }

    if (!(totalInput instanceof HTMLInputElement)) return;
    const price = getRowPrice(row);
    if (qtyRaw === null || !Number.isFinite(price)) {
      totalInput.value = '';
      const card = row.closest('.recipe-card');
      if (card instanceof HTMLElement) {
        updateCardTotal(card);
      }
      return;
    }
    const total = qtyRaw * price;
    totalInput.value = fmtNum(total, { minimumFractionDigits: 2, maximumFractionDigits: 2 });
    const card = row.closest('.recipe-card');
    if (card instanceof HTMLElement) {
      updateCardTotal(card);
    }
  };

  const applyItemDataToRow = (row, item) => {
    if (!(row instanceof HTMLElement) || !item || typeof item !== 'object') return;

    const setFieldValue = (field, value) => {
      const input = row.querySelector(`[data-field="${field}"]`);
      if (input instanceof HTMLInputElement) {
        input.value = value ?? '';
      }
    };

    setFieldValue('order_code', item.order_code ?? '');
    setFieldValue('item_name', item.item_name ?? '');
    setFieldValue('item_category', item.item_category ?? '');
    setFieldValue('base_unit', item.base_unit ?? '');

    const checkbox = row.querySelector('input[type="checkbox"]');
    if (checkbox instanceof HTMLInputElement) {
      checkbox.checked = Boolean(item.checked);
    }

    const parsedPrice = typeof item.base_price === 'number' && Number.isFinite(item.base_price)
      ? item.base_price
      : parseNumber(item.base_price);
    const normalizedPrice = typeof parsedPrice === 'number' && Number.isFinite(parsedPrice)
      ? parsedPrice
      : null;

    const priceInput = row.querySelector('[data-field="base_price"]');
    if (priceInput instanceof HTMLInputElement) {
      if (normalizedPrice !== null) {
        priceInput.dataset.raw = String(normalizedPrice);
        priceInput.value = fmtNum(normalizedPrice, { minimumFractionDigits: 2, maximumFractionDigits: 2 });
      } else {
        priceInput.value = '';
        delete priceInput.dataset.raw;
      }
    }

    row.dataset.itemId = item.stock_id ?? item.order_code ?? row.dataset.itemId ?? '';
    row.dataset.price = normalizedPrice !== null ? String(normalizedPrice) : '';

    const savedTotalQuantity = typeof item.total_quantity === 'number' && Number.isFinite(item.total_quantity)
      ? item.total_quantity
      : parseNumber(item.total_quantity);
    if (savedTotalQuantity !== null) {
      row.dataset.totalQuantity = String(savedTotalQuantity);
    } else {
      delete row.dataset.totalQuantity;
    }

    const orderCode = typeof item.order_code === 'string' ? item.order_code.trim() : '';
    if (orderCode) {
      const stockMatch = getStockByOrderCode(orderCode);
      if (stockMatch && typeof stockMatch.total_quantity === 'number' && Number.isFinite(stockMatch.total_quantity)) {
        row.dataset.totalQuantity = String(stockMatch.total_quantity);
      }
    }

    const parsedQty = typeof item.base_qty === 'number' && Number.isFinite(item.base_qty)
      ? item.base_qty
      : parseNumber(item.base_qty);
    const normalizedQty = typeof parsedQty === 'number' && Number.isFinite(parsedQty)
      ? parsedQty
      : null;

    updateTotalUsingRaw(row, normalizedQty, { formatQty: true });
    const card = row.closest('.recipe-card');
    if (card instanceof HTMLElement) {
      updateManufactureOutputs(card);
    }

    if (normalizedQty === null) {
      const qtyInput = row.querySelector('[data-field="base_qty"]');
      if (qtyInput instanceof HTMLInputElement && !qtyInput.value) {
        delete qtyInput.dataset.raw;
      }
    }

    if (normalizedPrice === null) {
      const priceField = row.querySelector('[data-field="base_price"]');
      if (priceField instanceof HTMLInputElement && !priceField.value) {
        delete priceField.dataset.raw;
      }
    }
  };

  const handleQtyInput = event => {
    const input = event.currentTarget;
    if (!(input instanceof HTMLInputElement)) return;
    const row = input.closest('.recipe-item-row');
    if (!(row instanceof HTMLElement)) return;
    const raw = parseNumber(input.value);
    updateTotalUsingRaw(row, raw, { formatQty: false });
    const card = row.closest('.recipe-card');
    if (card instanceof HTMLElement) {
      updateCardTotal(card);
      updateManufactureOutputs(card);
      queueSaveRecipe(card);
    }
  };

  const handleQtyFocus = event => {
    const input = event.currentTarget;
    if (!(input instanceof HTMLInputElement)) return;
    if (input.dataset.raw) {
      input.value = input.dataset.raw;
    }
  };

  const handleQtyBlur = event => {
    const input = event.currentTarget;
    if (!(input instanceof HTMLInputElement)) return;
    const row = input.closest('.recipe-item-row');
    if (!(row instanceof HTMLElement)) return;
    const raw = parseNumber(input.value);
    updateTotalUsingRaw(row, raw, { formatQty: true });
    const card = row.closest('.recipe-card');
    if (card instanceof HTMLElement) {
      updateCardTotal(card);
      updateManufactureOutputs(card);
      queueSaveRecipe(card);
    }
  };

  const bindQtyHandlers = row => {
    const qtyInput = row.querySelector('[data-field="base_qty"]');
    if (!(qtyInput instanceof HTMLInputElement)) return;
    if (qtyInput.dataset.boundQty === '1') return;
    qtyInput.addEventListener('input', handleQtyInput);
    qtyInput.addEventListener('focus', handleQtyFocus);
    qtyInput.addEventListener('blur', handleQtyBlur);
    qtyInput.dataset.boundQty = '1';
  };

  const bindRemoveHandler = row => {
    const removeButton = row.querySelector('.button-remove');
    if (!(removeButton instanceof HTMLButtonElement)) return;
    if (removeButton.dataset.boundRemove === '1') return;
    removeButton.addEventListener('click', () => {
      const card = row.closest('.recipe-card');
      hideRowSuggestions(row);
      row.remove();
      if (card instanceof HTMLElement) {
        updateCardTotal(card);
        updateManufactureOutputs(card);
        queueSaveRecipe(card);
      }
    });
    removeButton.dataset.boundRemove = '1';
  };

  const handleLookupInput = event => {
    const input = event.currentTarget;
    if (!(input instanceof HTMLInputElement)) return;
    const row = input.closest('.recipe-item-row');
    if (!(row instanceof HTMLElement)) return;
    const card = row.closest('.recipe-card');
    if (!(card instanceof HTMLElement)) return;

    clearRowStockData(row);
    input.dataset.lookupQuery = input.value;

    queueSaveRecipe(card);

    ensureStocksLoaded().then(() => {
      if (input.dataset.lookupQuery !== input.value) return;
      const query = input.value.trim();
      const results = query ? filterStockItems(query) : stockItems;
      renderRowSuggestions(card, row, results);
    }).catch(err => {
      console.error('[modal5.html] ошибка подстановки подсказок рецепта:', err);
    });
  };

  const handleLookupFocus = event => {
    const input = event.currentTarget;
    if (!(input instanceof HTMLInputElement)) return;
    const row = input.closest('.recipe-item-row');
    if (!(row instanceof HTMLElement)) return;
    const card = row.closest('.recipe-card');
    if (!(card instanceof HTMLElement)) return;

    ensureSuggestionContainer(row);
    ensureStocksLoaded().then(() => {
      const query = input.value.trim();
      const results = query ? filterStockItems(query) : stockItems;
      renderRowSuggestions(card, row, results);
    }).catch(err => {
      console.error('[modal5.html] ошибка показа подсказок рецепта:', err);
    });
  };

  const handleLookupBlur = event => {
    const input = event.currentTarget;
    if (!(input instanceof HTMLInputElement)) return;
    const row = input.closest('.recipe-item-row');
    if (!(row instanceof HTMLElement)) return;
    scheduleHideSuggestions(row);
  };

  const bindLookupHandlers = row => {
    const inputs = row.querySelectorAll('.code-field, .name-field, .category-field');
    inputs.forEach(field => {
      if (!(field instanceof HTMLInputElement)) return;
      if (field.dataset.boundLookup === '1') return;
      field.addEventListener('focus', handleLookupFocus);
      field.addEventListener('input', handleLookupInput);
      field.addEventListener('blur', handleLookupBlur);
      field.dataset.boundLookup = '1';
    });
    ensureSuggestionContainer(row);
  };

  const setupRecipeRow = (row, card) => {
    if (!(row instanceof HTMLElement)) return;
    bindQtyHandlers(row);
    bindRemoveHandler(row);
    bindLookupHandlers(row);
    const checkbox = row.querySelector('input[type="checkbox"]');
    if (checkbox instanceof HTMLInputElement && checkbox.type === 'checkbox' && checkbox.dataset.boundChange !== '1') {
      checkbox.addEventListener('change', () => {
        const hostCard = row.closest('.recipe-card');
        if (hostCard instanceof HTMLElement) {
          queueSaveRecipe(hostCard);
        }
      });
      checkbox.dataset.boundChange = '1';
    }
    if (card instanceof HTMLElement) {
      row.dataset.recipeId = card.dataset.recipeId ?? row.dataset.recipeId ?? '';
      updateManufactureOutputs(card);
    }
  };

  const focusFirstEditableField = row => {
    if (!(row instanceof HTMLElement)) return;
    const field = row.querySelector('.code-field');
    if (field instanceof HTMLInputElement) {
      field.focus();
      field.select();
    }
  };

  const createRecipeItemRow = (card, { focus = true, silent = false } = {}) => {
    if (!(card instanceof HTMLElement)) return null;
    const templateContent = itemTemplate.content?.firstElementChild;
    if (!(templateContent instanceof HTMLElement)) return null;
    const row = templateContent.cloneNode(true);
    if (!(row instanceof HTMLElement)) return null;
    row.dataset.itemId = '';
    clearRowStockData(row);
    const qtyInput = row.querySelector('[data-field="base_qty"]');
    if (qtyInput instanceof HTMLInputElement) {
      qtyInput.value = '';
      delete qtyInput.dataset.raw;
    }
    setupRecipeRow(row, card);
    const itemsContainer = card.querySelector('.recipe-card__items');
    if (!(itemsContainer instanceof HTMLElement)) return null;
    itemsContainer.appendChild(row);
    updateCardTotal(card);
    updateManufactureOutputs(card);
    if (focus) {
      focusFirstEditableField(row);
    }
    if (!silent) {
      const hostCard = card instanceof HTMLElement ? card : row.closest('.recipe-card');
      if (hostCard instanceof HTMLElement) {
        queueSaveRecipe(hostCard);
      }
    }
    return row;
  };

  const addItemToCard = (card, stock, { targetRow = null } = {}) => {
    if (!(card instanceof HTMLElement) || !stock || typeof stock !== 'object') return null;
    const itemsContainer = card.querySelector('.recipe-card__items');
    if (!(itemsContainer instanceof HTMLElement)) return null;
    const safeId = stock.id
      ? (typeof CSS !== 'undefined' && typeof CSS.escape === 'function'
        ? CSS.escape(String(stock.id))
        : String(stock.id).replace(/"/g, '\\"'))
      : '';
    let row = targetRow instanceof HTMLElement ? targetRow : null;
    if (safeId) {
      const existing = itemsContainer.querySelector(`.recipe-item-row[data-item-id="${safeId}"]`);
      if (existing instanceof HTMLElement && existing !== row) {
        row = existing;
        if (targetRow instanceof HTMLElement && targetRow !== existing) {
          targetRow.remove();
        }
      }
    }

    if (!(row instanceof HTMLElement)) {
      row = createRecipeItemRow(card, { focus: false, silent: true });
      if (!(row instanceof HTMLElement)) return null;
    }

    setupRecipeRow(row, card);
    if (stock.id !== undefined && stock.id !== null) {
      row.dataset.itemId = String(stock.id);
    }
    applyStockFields(row, stock);

    const qtyInput = row.querySelector('[data-field="base_qty"]');
    if (qtyInput instanceof HTMLInputElement) {
      const hasStoredRaw = Boolean(qtyInput.dataset.raw);
      const qtyRaw = hasStoredRaw
        ? parseNumber(qtyInput.dataset.raw)
        : parseNumber(qtyInput.value);
      updateTotalUsingRaw(row, qtyRaw, { formatQty: hasStoredRaw });
    }

    updateCardTotal(card);
    updateManufactureOutputs(card);
    queueSaveRecipe(card);

    return row;
  };

  const loadCardImageFromStorage = async card => {
    if (!supabaseClient) return null;
    if (!(card instanceof HTMLElement)) return null;
    const recipeId = card.dataset.recipeId;
    if (!recipeId) return null;
    const companyId = await resolveCompanyId();
    if (!companyId) return null;

    const bucket = supabaseClient.storage?.from(RECIPE_IMAGE_BUCKET);
    if (!bucket) return null;

    const path = `${companyId}/${recipeId}`;
    const { data } = bucket.getPublicUrl(path);
    const publicUrl = data?.publicUrl ?? '';
    if (!publicUrl) return null;

    const cacheBustedUrl = `${publicUrl}?t=${Date.now()}`;
    card.dataset.imageUrl = cacheBustedUrl;
    const meta = cardImageState.get(card) ?? {};
    cardImageState.set(card, { ...meta, path });
    return cacheBustedUrl;
  };

  const ensureRecipeId = async card => {
    if (!(card instanceof HTMLElement)) return null;
    if (card.dataset.recipeId) return card.dataset.recipeId;
    queueSaveRecipe(card, { immediate: true });
    const pending = cardSaveChains.get(card);
    if (pending) {
      try {
        await pending;
      } catch (err) {
        console.error('[modal5.html] ошибка ожидания сохранения рецепта перед загрузкой изображения:', err);
      }
    }
    return card.dataset.recipeId || null;
  };

  const uploadRecipeImage = async (card, file) => {
    if (!supabaseClient) return null;
    if (!(card instanceof HTMLElement)) return null;
    if (!(file instanceof File)) return null;

    const recipeId = await ensureRecipeId(card);
    if (!recipeId) {
      throw new Error('[modal5.html] невозможно загрузить изображение без идентификатора рецепта');
    }

    const companyId = await resolveCompanyId();
    if (!companyId) {
      throw new Error('[modal5.html] невозможно загрузить изображение без company_id');
    }

    const bucket = supabaseClient.storage?.from(RECIPE_IMAGE_BUCKET);
    if (!bucket) {
      throw new Error('[modal5.html] хранилище изображений недоступно');
    }

    const path = `${companyId}/${recipeId}`;
    const { error: uploadError } = await bucket.upload(path, file, {
      cacheControl: '3600',
      upsert: true,
      contentType: file.type || 'application/octet-stream',
    });

    if (uploadError) {
      throw uploadError;
    }

    const { data } = bucket.getPublicUrl(path);
    const publicUrl = data?.publicUrl ?? '';
    if (!publicUrl) {
      throw new Error('[modal5.html] не удалось получить публичный URL изображения рецепта');
    }

    const cacheBustedUrl = `${publicUrl}?t=${Date.now()}`;
    card.dataset.imageUrl = cacheBustedUrl;
    const meta = cardImageState.get(card) ?? {};
    cardImageState.set(card, { ...meta, path });
    queueSaveRecipe(card, { immediate: true });
    return cacheBustedUrl;
  };

  const setupCardVisual = (card, { imageUrl = '' } = {}) => {
    if (!(card instanceof HTMLElement)) return () => {};
    const fileInput = card.querySelector('.recipe-visual-card__input');
    const triggerButton = card.querySelector('.recipe-visual-card__button');
    const previewImage = card.querySelector('.recipe-visual-card__image img');

    if (!(fileInput instanceof HTMLInputElement) || !(previewImage instanceof HTMLImageElement)) {
      return () => {};
    }

    const placeholder = previewImage.getAttribute('data-placeholder') || previewImage.src || '';
    const state = cardImageState.get(card) ?? {};
    cardImageState.set(card, { ...state, placeholder });

    if (imageUrl) {
      card.dataset.imageUrl = imageUrl;
      previewImage.src = imageUrl;
    } else if (card.dataset.imageUrl) {
      previewImage.src = card.dataset.imageUrl;
    }

    const revokePreview = () => {
      const currentUrl = fileInput.dataset.previewUrl;
      if (currentUrl) {
        URL.revokeObjectURL(currentUrl);
        delete fileInput.dataset.previewUrl;
      }
    };

    const resetPreview = () => {
      if (placeholder) {
        previewImage.src = placeholder;
      } else {
        previewImage.removeAttribute('src');
      }
      try {
        fileInput.value = '';
      } catch (err) {
        /* ignore resetting file input */
      }
    };

    const updatePreview = () => {
      const file = fileInput.files && fileInput.files[0];
      revokePreview();
      if (file) {
        const objectUrl = URL.createObjectURL(file);
        fileInput.dataset.previewUrl = objectUrl;
        previewImage.src = objectUrl;
        if (supabaseClient) {
          uploadRecipeImage(card, file).then(url => {
            revokePreview();
            previewImage.src = url;
          }).catch(err => {
            console.error('[modal5.html] ошибка загрузки изображения рецепта:', err);
            resetPreview();
          });
        }
      } else {
        resetPreview();
      }
    };

    if (triggerButton instanceof HTMLButtonElement) {
      triggerButton.addEventListener('click', () => {
        try {
          fileInput.value = '';
        } catch (err) {
          /* ignore resetting file input before open */
        }
        fileInput.click();
      });
    }

    fileInput.addEventListener('change', updatePreview);

    if (!imageUrl && !card.dataset.imageUrl && supabaseClient) {
      loadCardImageFromStorage(card).then(loadedUrl => {
        if (loadedUrl) {
          previewImage.src = loadedUrl;
        }
      }).catch(err => {
        console.warn('[modal5.html] изображение рецепта не загружено из хранилища:', err);
      });
    }

    previewImage.addEventListener('error', () => {
      if (placeholder) {
        previewImage.src = placeholder;
      }
    });

    return () => {
      revokePreview();
      resetPreview();
    };
  };

  const setupManufactureToggle = card => {
    if (!(card instanceof HTMLElement)) return;
    const toggle = card.querySelector('.recipe-card__manufacture-toggle');
    if (!(toggle instanceof HTMLInputElement)) return;

    const controls = card.querySelector('.recipe-card__manufacture-controls');
    const controlsPrimaryField = controls?.querySelector('input, button, select, textarea');
    const multiplierInput = controls?.querySelector('.recipe-card__manufacture-multiplier');

    const focusOptions = { preventScroll: true };

    const scheduleFrame = typeof window !== 'undefined' && typeof window.requestAnimationFrame === 'function'
      ? window.requestAnimationFrame.bind(window)
      : (cb => setTimeout(cb, 0));
    const delay = typeof window !== 'undefined' && typeof window.setTimeout === 'function'
      ? window.setTimeout.bind(window)
      : ((cb, ms) => setTimeout(cb, ms));
    const cancelDelay = typeof window !== 'undefined' && typeof window.clearTimeout === 'function'
      ? window.clearTimeout.bind(window)
      : clearTimeout;

    const hideTimeouts = new WeakMap();
    const transitionHandlers = new WeakMap();
    const FALLBACK_DURATION = 600;

    const animateVisibility = (element, show, { visibleClass, hiddenClass } = {}) => {
      if (!(element instanceof HTMLElement)) return;

      const cancelFallback = () => {
        const timeoutId = hideTimeouts.get(element);
        if (typeof timeoutId === 'number') {
          cancelDelay(timeoutId);
          hideTimeouts.delete(element);
        }
      };

      const clearTransitionHandler = () => {
        const handler = transitionHandlers.get(element);
        if (typeof handler === 'function') {
          element.removeEventListener('transitionend', handler);
          transitionHandlers.delete(element);
        }
      };

      const applyHiddenState = () => {
        if (visibleClass) {
          element.classList.remove(visibleClass);
        }
        if (hiddenClass) {
          element.classList.add(hiddenClass);
        }
        element.hidden = true;
      };

      element.setAttribute('aria-hidden', show ? 'false' : 'true');

      if (show) {
        clearTransitionHandler();
        cancelFallback();
        if (hiddenClass) {
          element.classList.remove(hiddenClass);
        }
        element.hidden = false;
        scheduleFrame(() => {
          if (visibleClass) {
            element.classList.add(visibleClass);
          }
        });
        return;
      }

      if (element.hidden) {
        if (visibleClass) {
          element.classList.remove(visibleClass);
        }
        if (hiddenClass) {
          element.classList.add(hiddenClass);
        }
        return;
      }

      const onTransitionEnd = event => {
        if (event.target !== element) return;
        clearTransitionHandler();
        cancelFallback();
        applyHiddenState();
      };

      transitionHandlers.set(element, onTransitionEnd);
      element.addEventListener('transitionend', onTransitionEnd);

      if (visibleClass) {
        element.classList.remove(visibleClass);
      }
      if (hiddenClass) {
        element.classList.add(hiddenClass);
      }

      const timeoutId = delay(() => {
        clearTransitionHandler();
        applyHiddenState();
        hideTimeouts.delete(element);
      }, FALLBACK_DURATION);

      hideTimeouts.set(element, timeoutId);
    };

    const applyState = () => {
      const enabled = toggle.checked;
      
      if (controls instanceof HTMLElement) {
        animateVisibility(controls, enabled, { visibleClass: 'is-visible' });
        if (enabled && controlsPrimaryField instanceof HTMLElement) {
          scheduleFrame(() => controlsPrimaryField.focus(focusOptions));
        }
      }
      updateManufactureOutputs(card);
      if (!enabled) {
        const firstNoteInput = card.querySelector('.recipe-card__common-notes:not([hidden]) .recipe-card__common-notes-textarea');
        if (firstNoteInput instanceof HTMLTextAreaElement) {
          scheduleFrame(() => firstNoteInput.focus(focusOptions));
        }
      }
    };

    if (multiplierInput instanceof HTMLInputElement && multiplierInput.dataset.boundManufacture !== '1') {
      const handleMultiplierUpdate = () => updateManufactureOutputs(card);
      multiplierInput.addEventListener('input', handleMultiplierUpdate);
      multiplierInput.addEventListener('blur', () => {
        handleMultiplierUpdate();
        const parsed = parseNumber(multiplierInput.value);
        if (parsed !== null) {
          multiplierInput.value = fmtNum(parsed, { minimumFractionDigits: 0, maximumFractionDigits: 3 });
        }
      });
      multiplierInput.dataset.boundManufacture = '1';
    }

    if (controls instanceof HTMLElement) {
      const manufactureButton = controls.querySelector('.button-form.primary');
      if (manufactureButton instanceof HTMLButtonElement && manufactureButton.dataset.boundManufacture !== '1') {
        const handleManufacture = async () => {
          updateManufactureOutputs(card);

          if (!supabaseClient) {
            alert('Supabase недоступен, создание записей невозможно.');
            return;
          }

          if (!(multiplierInput instanceof HTMLInputElement)) {
            alert('Поле количества недоступно.');
            return;
          }

          const multiplier = parseNumber(multiplierInput.value);
          if (multiplier === null || multiplier <= 0) {
            alert('Укажите количество изготавливаемого товара.');
            return;
          }

          const recipeCode = getCardFieldValue(card, 'recipe_code');
          const recipeName = getCardFieldValue(card, 'recipe_name');
          const recipeCategory = getCardFieldValue(card, 'recipe_category');

          if (!recipeCode || !recipeName) {
            alert('Заполните код и наименование рецепта перед изготовлением.');
            return;
          }

          const rows = Array.from(card.querySelectorAll('.recipe-item-row'));
          if (!rows.length) {
            alert('Добавьте материалы в рецепт перед изготовлением.');
            return;
          }

          const totalField = card.querySelector('.recipe-card__total');
          const totalPrice = totalField instanceof HTMLInputElement
            ? parseNumber(totalField.value)
            : null;

          const companyId = await resolveCompanyId();

          const productRecord = {
            order_code: recipeCode,
            item_name: recipeName,
            item_category: recipeCategory,
            url: '',
            supplier: '-',
            modification: 'шт',
            quantity_value: numberToStorageString(multiplier),
            price_value: numberToStorageString(totalPrice ?? 0),
            status: 'изготовлено',
          };

          if (DB_USER_KEY) {
            productRecord.user_key = DB_USER_KEY;
          }
          if (companyId) {
            productRecord.company_id = companyId;
          }

          const materialRecords = [];

          await Promise.all(rows.map(async row => {
            if (!(row instanceof HTMLElement)) return;
            const orderCode = getRowFieldValue(row, 'order_code');
            if (!orderCode) return;

            const resultField = row.querySelector('.recipe-card__manufacture-result');
            const requiredQty = resultField instanceof HTMLInputElement
              ? parseNumber(resultField.value)
              : null;

            if (requiredQty === null || requiredQty === 0) return;

            const snapshot = await fetchLatestOrderSnapshot(orderCode, { companyId }).catch(() => null);
            const rowName = getRowFieldValue(row, 'item_name');
            const rowCategory = getRowFieldValue(row, 'item_category');
            const rowUnit = getRowFieldValue(row, 'base_unit');
            const unitPrice = getRowPrice(row);

            const record = {
              order_code: orderCode,
              item_name: snapshot?.item_name ?? rowName,
              item_category: snapshot?.item_category ?? rowCategory,
              url: '',
              supplier: '-',
              modification: rowUnit,
              status: 'списание',
              quantity_value: numberToStorageString(-Math.abs(requiredQty)),
              price_value: numberToStorageString(unitPrice ?? 0),
            };

            if (DB_USER_KEY) {
              record.user_key = DB_USER_KEY;
            }
            if (companyId) {
              record.company_id = companyId;
            }

            materialRecords.push(record);
          }));

          const recordsToInsert = [productRecord, ...materialRecords];

          if (recordsToInsert.length === 1) {
            alert('Не удалось определить материалы для списания.');
            return;
          }

          manufactureButton.disabled = true;
          manufactureButton.dataset.loading = '1';

          try {
            const { error } = await supabaseClient
              .from('modal4_orders')
              .insert(recordsToInsert);

            if (error) {
              throw error;
            }

            multiplierInput.value = '';
            delete multiplierInput.dataset.raw;
            toggle.checked = false;
            applyState();
            updateManufactureOutputs(card);
          } catch (err) {
            alert('Не удалось создать записи в modal4_orders. Подробности в консоли.');
            console.error('[modal5.html] ошибка создания записей modal4_orders:', err);
          } finally {
            manufactureButton.disabled = false;
            delete manufactureButton.dataset.loading;
          }
        };

        manufactureButton.addEventListener('click', handleManufacture);
        manufactureButton.dataset.boundManufacture = '1';
      }
    }


    toggle.addEventListener('change', applyState);
    applyState();
    updateManufactureOutputs(card);
  };


  const setupAddButton = card => {
    const addButton = card.querySelector('.recipe-card__add');
    if (!(addButton instanceof HTMLButtonElement)) return;
    if (addButton.dataset.boundAdd === '1') return;
    addButton.addEventListener('click', () => {
      ensureStocksLoaded().then(() => {
        createRecipeItemRow(card);
      }).catch(err => {
        console.error('[modal5.html] ошибка при добавлении строки рецепта:', err);
      });
    });
    addButton.dataset.boundAdd = '1';
  };

  const updateAllRecipeItems = () => {
    const rows = recipeList.querySelectorAll('.recipe-item-row');
    const changedCards = new Set();
    const cardsToUpdate = new Set();
    rows.forEach(row => {
      if (!(row instanceof HTMLElement)) return;
      const card = row.closest('.recipe-card');
      if (card instanceof HTMLElement) {
        setupRecipeRow(row, card);
      }
      const itemId = row.dataset.itemId;
      if (!itemId) return;
      const latest = stockMap.get(itemId);
      if (!latest) return;
      const beforePrice = row.dataset.price ?? '';
      applyStockFields(row, latest);
      const qtyInput = row.querySelector('[data-field="base_qty"]');
      const hasStoredRaw = qtyInput instanceof HTMLInputElement && qtyInput.dataset.raw;
      const qtyRaw = hasStoredRaw
        ? parseNumber(qtyInput.dataset.raw)
        : parseNumber(qtyInput instanceof HTMLInputElement ? qtyInput.value : null);
      updateTotalUsingRaw(row, qtyRaw, { formatQty: Boolean(hasStoredRaw) });
      if (card instanceof HTMLElement) {
        const afterPrice = row.dataset.price ?? '';
        if (beforePrice !== afterPrice) {
          changedCards.add(card);
        }
        updateCardTotal(card);
        cardsToUpdate.add(card);
      }
    });
    cardsToUpdate.forEach(card => {
      if (card instanceof HTMLElement) {
        updateManufactureOutputs(card);
      }
    });
    changedCards.forEach(card => {
      if (card instanceof HTMLElement) {
        queueSaveRecipe(card);
      }
    });
  };

  const createRecipeCard = (data = {}) => {
    const templateContent = cardTemplate.content?.firstElementChild;
    if (!(templateContent instanceof HTMLElement)) {
      throw new Error('[modal5.html] шаблон карточки рецепта недоступен');
    }
    const card = templateContent.cloneNode(true);
    if (!(card instanceof HTMLElement)) {
      throw new Error('[modal5.html] не удалось создать карточку рецепта');
    }

    const createdAtIso = toIsoString(data.createdAt || new Date());
    card.dataset.recipeId = data.id ? String(data.id) : '';
    card.dataset.createdAt = createdAtIso;
    if (data.updatedAt) {
      card.dataset.updatedAt = toIsoString(data.updatedAt);
    }
    if (data.imageUrl) {
      card.dataset.imageUrl = data.imageUrl;
    } else {
      delete card.dataset.imageUrl;
    }

    const setField = (field, value) => {
      const target = card.querySelector(`[data-field="${field}"]`);
      if (target instanceof HTMLInputElement) {
        target.value = value ?? '';
      }
    };

    setField('recipe_code', data.code ?? '');
    setField('recipe_category', data.category ?? '');
    setField('recipe_name', data.name ?? '');

    const cleanupVisual = setupCardVisual(card, { imageUrl: data.imageUrl ?? '' });

    const dateField = card.querySelector('[data-field="date-time"]');
    if (dateField) {
      applyDateTime(dateField, createdAtIso);
    }

    const deleteButton = card.querySelector('.recipe-card__delete');
    if (deleteButton instanceof HTMLButtonElement) {
      deleteButton.addEventListener('click', () => {
        cleanupVisual();
        cancelQueuedSave(card);
        const recipeId = card.dataset.recipeId;
        card.remove();
        if (recipeId) {
          deleteRecipeById(recipeId);
        }
      });
    }

    setupManufactureToggle(card);
    setupAddButton(card);
    const itemsContainer = card.querySelector('.recipe-card__items');
    if (itemsContainer instanceof HTMLElement) {
      itemsContainer.innerHTML = '';
      if (Array.isArray(data.items)) {
        data.items.forEach(item => {
          const row = createRecipeItemRow(card, { focus: false, silent: true });
          if (row instanceof HTMLElement) {
            applyItemDataToRow(row, item);
          }
        });
      }
    }

    captureCardStateHash(card);
    return card;
  };

  const loadExistingRecipes = async () => {
    if (!supabaseClient) return;
    try {
      const companyId = await resolveCompanyId();
      if (!companyId) return;

      const { data, error } = await supabaseClient
        .from(RECIPES_TABLE)
        .select('id, recipe_code, recipe_category, recipe_name, items, created_at, updated_at')
        .eq('company_id', companyId)
        .order('created_at', { ascending: false });

      if (error) {
        console.error('[modal5.html] ошибка загрузки рецептов:', error);
        return;
      }

      if (!Array.isArray(data)) return;

      data.forEach(row => {
        const storedImageUrl = typeof row?.image_url === 'string' ? row.image_url : '';
        const card = createRecipeCard({
          id: row?.id ?? null,
          code: row?.recipe_code ?? '',
          category: row?.recipe_category ?? '',
          name: row?.recipe_name ?? '',
          imageUrl: storedImageUrl,
          createdAt: row?.created_at ?? row?.updated_at ?? new Date(),
          updatedAt: row?.updated_at ?? null,
          items: Array.isArray(row?.items) ? row.items : [],
        });
        recipeList.appendChild(card);
      });

      ensureStocksLoaded().then(() => {
        updateAllRecipeItems();
      }).catch(err => {
        console.error('[modal5.html] ошибка обновления рецептов после загрузки склада:', err);
      });
    } catch (err) {
      console.error('[modal5.html] исключение при загрузке рецептов:', err);
    }
  };

  const clearForm = () => {
    [recipeCodeInput, recipeCategoryInput, recipeNameInput].forEach(input => {
      input.value = '';
      input.classList.remove('input--error');
    });
  };

  const createRecipeFromForm = () => {
    const code = recipeCodeInput.value.trim();
    const category = recipeCategoryInput.value.trim();
    const name = recipeNameInput.value.trim();

    const inputs = [
      { el: recipeCodeInput, value: code },
      { el: recipeCategoryInput, value: category },
      { el: recipeNameInput, value: name },
    ];

    let hasError = false;
    inputs.forEach(({ el, value }) => {
      const empty = !value;
      el.classList.toggle('input--error', empty);
      if (empty) hasError = true;
    });

    if (hasError) return;

    const createdAt = new Date();
    const card = createRecipeCard({ code, category, name, createdAt });
    recipeList.prepend(card);
    queueSaveRecipe(card, { immediate: true });
    clearForm();
  };

  const refreshStocks = async ({ silent = false } = {}) => {
    if (!supabaseClient) {
      stocksLoaded = true;
      stockCodeMap = new Map();
      if (!silent) {
        console.warn('[modal5.html] Supabase недоступен, складские позиции не будут загружены');
      }
      return stockItems;
    }

    if (isLoadingStocks) return stockItems;
    isLoadingStocks = true;

    try {
      const { data, error } = await supabaseClient
        .from('modal4_orders_uni')
        .select('order_code, item_name, item_category, total_quantity, avg_cost, stock_value, base_unit');

      if (error) {
        if (!silent) {
          console.error('[modal5.html] ошибка загрузки modal4_orders_uni:', error);
        }
        return stockItems;
      }

      const normalized = Array.isArray(data)
        ? data.map(normalizeStockRow).filter(Boolean)
        : [];

      stockItems = normalized;
      stockMap = new Map(normalized.map(item => [item.id, item]));
      stockCodeMap = new Map();
      normalized.forEach(item => {
        const key = normalizeOrderCode(item.order_code);
        if (key) {
          stockCodeMap.set(key, item);
        }
      });
      stocksLoaded = true;
      updateAllRecipeItems();
      return stockItems;
    } finally {
      isLoadingStocks = false;
    }
  };

  const ensureStocksLoaded = async () => {
    if (stocksLoaded) return stockItems;
    return refreshStocks({ silent: true });
  };

  const scheduleStocksRefresh = () => {
    if (!supabaseClient) return;
    if (refreshTimerId) clearInterval(refreshTimerId);
    refreshTimerId = setInterval(() => {
      refreshStocks({ silent: true }).catch(err => {
        console.error('[modal5.html] ошибка фонового обновления складских позиций:', err);
      });
    }, 60_000);
  };

  const preloadedCards = recipeList.querySelectorAll('.recipe-card');
  preloadedCards.forEach(card => {
    if (!(card instanceof HTMLElement)) return;
    setupCardVisual(card, { imageUrl: card.dataset.imageUrl ?? '' });
    setupAddButton(card);
    const rows = card.querySelectorAll('.recipe-item-row');
    rows.forEach(row => {
      if (row instanceof HTMLElement) {
        setupRecipeRow(row, card);
      }
    });
    captureCardStateHash(card);
  });

  createButton.addEventListener('click', createRecipeFromForm);

  [recipeCodeInput, recipeCategoryInput, recipeNameInput].forEach(input => {
    input.addEventListener('input', () => {
      input.classList.remove('input--error');
    });
  });

  if (supabaseClient) {
    loadExistingRecipes().catch(err => {
      console.error('[modal5.html] ошибка первичной загрузки рецептов:', err);
    });
    refreshStocks({ silent: true }).catch(err => {
      console.error('[modal5.html] ошибка первоначальной загрузки склада:', err);
    });
    scheduleStocksRefresh();
    window.addEventListener('focus', () => {
      refreshStocks({ silent: true }).catch(err => {
        console.error('[modal5.html] ошибка обновления склада при возвращении на вкладку:', err);
      });
    });
  }

  console.log('[modal5.html] PAGE 5 активирован');
}
  
initModal5();
</script>
